#+title: Séquençage WS et SW

Ce dossier contient les séquences des plaques obtenues avec les
constructions SW et WS, envoyées à séquencer le [2016-03-15 Tue].

* Dossiers et fichiers
Les données brutes au format .zip sont dans le dossier =raw=. Elles
sont extraites dans le dossier =data=, séparé en =ws= et =sw= pour les
analyses. Rien ne doit toucher au dossier =raw=.

J'ai ensuite utilisé le script [[./src/sort_into_dir.sh]] pour classer les
fichiers selon leur extension.

#+BEGIN_SRC sh :tangle src/sort_into_dir.sh
#!/bin/bash

cd data/ws

mkdir fasta spectro seq

find . -name "*.fas"  -maxdepth 1 -exec mv {} ./fasta/ \;
find . -name "*.ab1"  -maxdepth 1 -exec mv {} ./spectro/ \;
find . -name "*.seq"  -maxdepth 1 -exec mv {} ./seq/ \;
find . -name "*.csv"  -maxdepth 1 -exec mv {} ../csv/ \;

cd ../sw

mkdir fasta spectro seq

find . -name "*.fas"  -maxdepth 1 -exec mv {} ./fasta/ \;
find . -name "*.ab1"  -maxdepth 1 -exec mv {} ./spectro/ \;
find . -name "*.seq"  -maxdepth 1 -exec mv {} ./seq/ \;
find . -name "*.csv"  -maxdepth 1 -exec mv {} ../csv/ \;
#+END_SRC

* Contrôle qualité
Après avoir reçu les séquences, j'ai voulu connaître la qualité
globale des séquences. Je les ai donc converties en fastq avec le
script [[./src/ab1_to_fastq.sh]], et j'ai utilisé ~fastqc~ pour
représenter la qualité globale via le script [[./src/quality_control.sh]].

#+BEGIN_SRC sh :tangle src/ab1_to_fastq.sh
#!/bin/bash

# transforme en fastq
cd data/ws

touch ws_untrimmed.fastq

for file in spectro/*.ab1
do
    seqret \
        -sformat abi \
        -osformat fastq \
        -auto \
        -stdout \
        -sequence $file \
        >> ws_untrimmed.fastq
done

cd ../sw

# TEMPORAIRE, élimine le fichier .ab1 tendancieux pour l'instant
# rm spectro/psw76-1073bis.ab1

touch sw_untrimmed.fastq

for file in spectro/*.ab1
do
    seqret \
        -sformat abi \
        -osformat fastq \
        -auto \
        -stdout \
        -sequence $file \
        >> sw_untrimmed.fastq
done
#+END_SRC

J'ai utilisé ~fastqc~ pour représenter la qualité globale via le
script [[./src/quality_control.sh]].

#+BEGIN_SRC sh :tangle src/quality_control.sh
#!/bin/bash

# contrôle qualité des séquences.
cd data

# crée un dossier qc de quality control pour ws et sw
mkdir -p qc/{ws,sw}

# fastqc sortie dasn le dossier approprié
fastqc ws/ws_untrimmed.fastq -o qc/ws
fastqc sw/sw_untrimmed.fastq -o qc/sw

# transfert du fichier .png qui nous intéresse dans le dir adapté
# et suppression des dossiers inutiles
#' -qq : very quiet
#' -o  : overwrite without warning
#' -d  : out dir
unzip -qq -o \
      qc/sw/sw_untrimmed_fastqc.zip \
      sw_untrimmed_fastqc/Images/per_base_quality.png \
      -d ../anl/ \
    && mv ../anl/sw_untrimmed_fastqc/Images/per_base_quality.png \
          ../anl/sw_per_base_qual.png \
    && rm -r ../anl/sw_untrimmed_fastqc

# transfert du fichier .png qui nous intéresse dans le dir adapté
# et suppression des dossiers inutiles
unzip -qq -o \
      qc/ws/ws_untrimmed_fastqc.zip \
      ws_untrimmed_fastqc/Images/per_base_quality.png \
      -d ../anl/ \
    && mv ../anl/ws_untrimmed_fastqc/Images/per_base_quality.png \
          ../anl/ws_per_base_qual.png \
    && rm -r ../anl/ws_untrimmed_fastqc
#+END_SRC

À priori les séquences sont plutôt de bonne qualité. Voir le résumé
dans le fichier [[./data/qc/sw/sw_untrimmed_fastqc.html]] et
[[./data/qc/ws/ws_untrimmed_fastqc.html]].

* Analyse rapide du SNP calling de GATC
J'ai rapidement analysé la sortie du SNP calling effectué par GATC,
mais il manque des données. Je vais refaire le SNP calling moi-même,
en utilisant dans un premier temps ssaha2.

#+BEGIN_SRC R :tangle anl/gatc_snpcall/snp_call.r :exports none
  #' ---
  #' title: "Rapide analyse des SNP"
  #' author: "Samuel BARRETO"
  #' date: "31 janvier 2016"
  #' output:
  #'   html_document:
  #'     highlight: tango
  #'     theme: paper
  #'     code_folding: hide
  #'     toc: true
  #'     toc_depth: 2
  #'     toc_float: true
  #' ---

  #' # Lecture des données
  #'
  #' Les données sont les tableurs de snp calling que GATC nous a fait
  #' gratuitement. Ce script n'est que préliminaire, je referai le snp
  #' calling comme il faut par la suite.
  library(dplyr)
  library(ggplot2)
  library(readr)
  library(viridis)

  #' Lecture des données et combinaison dans un seul tableur.
  ws <- read_delim("../../data/csv/1582203.SNP.csv", delim = ";")
  sw <- read_delim("../../data/csv/1582443.SNP.csv", delim = ";")
  ws$type <- "ws"
  sw$type <- "sw"

  #' ## Définition des transitions
  #'
  ## #' une fonction qui définit le type de transition, de la référence
  ## #' à la séquence observée.
  find_transition <- function(ref, base) {
    stopifnot(typeof(ref) == "character", typeof(base) == "character")

    is_W <- function(base) ifelse(base == "A" || base == "T", TRUE, FALSE)
    is_S <- function(base) ifelse(base == "C" || base == "G", TRUE, FALSE)

    if (is_W(ref) & is_S(base)) "ws"
    else if (is_S(ref) & is_W(base)) "sw"
    else if (is_S(ref) & is_S(base)) "ss"
    else if (is_W(ref) & is_W(base)) "ww"
    else stop("Base ", ref, " or base ", base, " is not a DNA base.",
              call. = FALSE)
  }

  data <- rbind(ws, sw) # lie les deux jeux de données
                                          # change les noms de colonne
  colnames(data) <-  c("ref", "pos", "ref.base", "alt.base", "qual",
                       "query", "qpos", "qlen", "type")
                                          # supprime le nom de l'amorce
  data <- mutate(data, query = gsub("-1073bis", "", query))

  ## ggplot default theme
  theme_set(theme_minimal(base_size = 10, base_family = "Courier"))

  #' # Distribution des SNP
  #' Je regarde la distribution des SNP sur les séquences
                                          ,#+distrisnp
  data %>%
    ggplot(aes(x = pos, fill = type)) +
    geom_histogram(binwidth = 10) +
    facet_grid(type~.) +
    xlab("Position sur la reference") +
    ylab("Nombre de SNP")

  #' ## Alignement des séquences
  #'
  #' Je fais rapidement un petit alignement des séquences
  #'
  data %>%
    ggplot(data = ., aes(x = pos, y  = query )) +
    ## geom_text(aes(label = alt.base)) +
    geom_point(aes(color = alt.base), alpha = 0.4)

  data %>%
    group_by(query) %>%
    summarise(end.tc = max(pos)) %>%
    ggplot(aes(x = end.tc)) +
    geom_histogram()

  data %>% select(query) %>% unique()

  #' ## Problème avec les séquences
  #'
  #' Il n'y a que 127 séquences analysées dans ce tableau. Ça ne va pas.
  #' On devrait s'attendre à 192 séquences normalement. Il manque du
  #' signal. Je vais faire l'analyse moi-même.

  data %>%
    select(query) %>%
    unique()
#+END_SRC

Le script est là [[./anl/gatc_snpcall/snp_call.r]], les sorties en
html là [[./anl/gatc_snpcall/snp_call.html]].

* SNP calling global
** trimming des séquences

J'ai utilisé le programme bbduk pour trimmer les séquences de faible
qualité.

#+BEGIN_SRC sh :tangle src/qtrim.sh
  #!/bin/bash

  #' -qtrim=rl : quality trim right and left
  #' -trimq=28 : trim if quality < 28 (sanger encoding, illumina 1.9)
  #' -minlen=620 : keep only seq with length > 620, after trimming.
  #' -Xmx1g : tells bbduk / java to use 1G of RAM

  FASTQ="data/sw/sw_untrimmed.fastq
  data/ws/ws_untrimmed.fastq
  "

  for f in $FASTQ
  do
      out=$f.trim
      bin/bbmap/bbduk.sh -Xmx1g \
                         -in=$f \
                         -out=$f.qtrim \
                         -qtrim=rl \
                         -trimq=28 \
                         -minlen=600

      ## convertit les bases d'une qualité inférieure à 20 en N.
      seqtk seq \
            -q20 \
            -nN \
            $f.qtrim > $out

      ## convertit le fastq en fasta
      seqret \
          -sformat fastq \
          -osformat fasta \
          -auto -stdout \
          -sequence $out > $f.fasta

      rm $f.qtrim
  done
#+END_SRC

** Contrôle qualité des séquences trimmées

#+begin_src sh :tangle src/qtrim_qc.sh
  #!/usr/bin/env bash

  cd data

  TRIM="ws/ws_untrimmed.fastq.trim sw/sw_untrimmed.fastq.trim"

  mkdir qtrim_qc

  for f in $TRIM
  do
      fastqc $f -o qtrim_qc
  done
#+end_src

Le script est là [[./src/qtrim_qc.sh]] et les sorties sont là
[[file:data/qtrim_qc/sw_untrimmed.fastq.trim_fastqc.html][./data/qtrim_qc/sw_untrimmed.fastq.trim_fastqc.html]] et là
[[file:data/qtrim_qc/sw_untrimmed.fastq.trim_fastqc.html][./data/qtrim_qc/ws_untrimmed.fastq.trim_fastqc.html]].

Les séquences sont nettement raccourcies par rapport aux séquences non trimmées. Mais l'ensemble des
bases qu'on veut analyser sont de bonne qualité. C'est donc plutôt bon signe.

** Pooling des séquences dans un seul fastq

#+BEGIN_SRC sh :tangle src/pool_trim.sh
  #!/usr/bin/env bash

  cat data/sw/sw_untrimmed.fastq.trim data/ws/ws_untrimmed.fastq.trim > data/trimmed.fastq
#+END_SRC

[[./src/pool_trim.sh]]

** Analyses des alignements via seaview
Pour les analyses dans seaview, il faut un fichier fasta. Je lui
ajoute la référence.

#+BEGIN_SRC sh :tangle src/trim_to_fasta.sh
#!/usr/bin/env bash

seqret -sformat fastq -osformat fasta -auto -stdout \
       -sequence data/trimmed.fastq > data/trimmed.fasta

fastx_reverse_complement \
    -i raw/ref/reference1073bis-1392.fasta \
    >> data/trimmed.fasta

#+END_SRC

[[./src/trim_to_fasta.sh]]

J'ai placé les différentes analyses graphiques via seaview dans le
dossier [[./anl/align]].

Différents alignements :
- l'alignement global : [[./anl/align/trimmed.mase][./anl/align/trimmed.mase]]
- l'alignement avec seulement les sites variables : [[./anl/align/variable_site.mase]]

Sur l'alignement global, j'ai repéré quelques cas de traces complexes,
où des séquences avaient ‘gardé’ leur allèle sauvage, quand les deux
SNP environnants sont les SNP transformants.

** snp calling via ssahaSNP

Pour installer ssahaSNP voir les instructions là :
ftp://ftp.sanger.ac.uk/pub/resources/software/ssahasnp/.

Il est très important que les fichiers fasta de référence soit formattés de la
bonne façon, sinon ssahaSNP ne sort pas les bonnes valeurs dans les lignes de
tableau.

#+begin_src sh :tangle src/snp_call.sh
   #!/usr/bin/env bash

   # Variant calling using ssaha2 and ssahaSNP

   if [ ! -e data/snp_call ]
   then
       mkdir data/snp_call
   fi

   cd data/snp_call

   if [[ ! -e trimmed.fastq && ! -e ref.fasta ]]
   then
       ln -s    ../trimmed.fastq .
       ln -s ../../raw/ref/reference1073bis-1392.fasta ref.fasta
   fi

   ## alignement à la séquence de référence
   #' -output psl :             format de sortie psl
   #' reference_reverse.fasta : séquence de référence
   #' trimmed.fastq :           séquence à aligner
   #' output.psl :              fichier de sortie
   ../../bin/ssahaSNP/ssaha2 -output psl ref.fasta trimmed.fastq > output.psl

   ## column annotation based on
   ## ftp://ftp.sanger.ac.uk/pub/resources/software/ssahasnp/readme,
   ## part (6) some further information
   # la première ligne du fichier .dat, afin d'être lu dans R
   cat \
       <( echo "match subject_name index_of_subject read_name s_base q_base s_qual q_qual offset_on_subject offset_on_read length_of_snp start_match_of_read end_match_of_read match_direction length_of_subject" ) \
       <( ../../bin/ssahaSNP/ssahaSNP ref.fasta trimmed.fastq | \
                egrep ssaha:SNP | \
                awk '{print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15}') \
       > snp_calling.dat
#+end_src

Le script est là : [[./src/snp_call.sh]].

** création de la table d'identification des clones
Les spectrogrammes contiennent l'info permettant de relier à un
identifiant de séquence le nom expérimental qu'on lui a attribué.

#+BEGIN_SRC python :tangle src/make_id_table.py
  #!/usr/bin/env python

  from Bio import SeqIO
  from glob import glob
  from os.path import basename

  def sw_or_ws(mutant_name):
      """
      Determine si le mutant est SW ou WS
      """
      if 'sw' in mutant_name:
          return 'sw'
      else:
          return 'ws'

  # en tete de colonne
  print "id name mutant"

  def print_seq_id(dna_seq):
      with open(dna_seq, "rb") as spectro:
          sequence = list(SeqIO.parse(spectro, "abi"))
          print sequence[0].id + " " + sequence[0].name + " " + sw_or_ws(sequence[0].name)

  for file in glob("data/sw/spectro/*.ab1"):
      if basename(file) != "psw76-1073bis.ab1": # exclut la sequence qui pose probleme
          print_seq_id(file)

  for file in glob("data/ws/spectro/*.ab1"):
      print_seq_id(file)
#+END_SRC

** Analyses des résultats de snp calling
#+BEGIN_SRC R :tangle anl/snp_call/snp_call.r :exports none
#' ---
#' title: Analyse globale des SNP
#' author: Samuel BARRETO
#' date:
#' output:
#'   tufte::tufte_html:
#'     highlight: tango
#'     toc: true
#'     toc_depth: 2
#' ---


#' # Lecture des données et nettoyage
#'
#' Il faut dans un premier temps lire les données, les nettoyer et associer à
#' chaque séquence la catégorie de plasmide transformeur.
#'
#' La table des identifiants est faite par le script python.
#'

,#+ setup, include=FALSE
library(knitr)
library(tufte)
opts_chunk$set(cache = FALSE, dev = 'png', include = TRUE,
               echo = TRUE, warning = FALSE, error = FALSE,
               message = FALSE)

fte_theme <- function() {
  ## Generate the colors for the chart procedurally with RColorBrewer
  palette <- RColorBrewer::brewer.pal("Greys", n=9)
  color.background = palette[2]
  color.grid.major = palette[3]
  color.axis.text = palette[6]
  color.axis.title = palette[7]
  color.title = palette[9]

  ## Begin construction of chart
  theme_bw(base_size=9) +
    ## Set the entire chart region to a light gray color
    theme(panel.background=element_rect(fill=color.background, color=color.background),
          plot.background=element_rect(fill=color.background, color=color.background),
          panel.border=element_rect(color=color.background),
          panel.grid.major=element_line(color=color.grid.major,size=.25),
          panel.grid.minor=element_blank(),
          axis.ticks=element_blank(),
          ## Format the legend, but hide by default
          legend.position="none",
          legend.background = element_rect(fill = scales::alpha(color.background, 0.3)),
          legend.text = element_text(size=7,color=color.axis.title),
          ## Set title and axis labels, and format these and tick marks
          plot.title=element_text(color=color.title, size=14,
                                  face = "bold", vjust=1.25, hjust = 0),
          axis.text.x=element_text(size=7,color=color.axis.text),
          axis.text.y=element_text(size=7,color=color.axis.text),
          axis.title.x=element_text(size=8, color=color.axis.title, vjust=0, hjust = 0.8),
          axis.title.y=element_text(size=8, color=color.axis.title, vjust = 0.9, angle = 0 ),
          ## Plot margins
          plot.margin = unit(c(0.35, 0.2, 0.3, 0.35), "cm"))
}

legend_position <- function(x, y) theme(legend.position = c(x, y))

,#+ setup2, include = TRUE
library(dplyr)
library(ggplot2)
library(readr)
library(viridis)
library(purrr)
library(ggthemes)

theme_set(theme_bw() + fte_theme())

data_location <- "../../data/snp_call/snp_calling.dat"
id_table_loc <- "../../data/id_table.dat"

#' J'ai relié les données par un `inner_join` sur la base du nom de
#' l'identifiant de la séquence GATC.

snp <- inner_join(
  x = read_delim(file = data_location, delim = " "),
  y = read_delim(file = id_table_loc, delim = " "),
  by=c("read_name" = "id")) %>%
  select(
    -match,
    -subject_name,
    -index_of_subject,
    read = read_name,
    refb = s_base,
    readb = q_base,
    -s_qual,
    base_q = q_qual,
    refp = offset_on_subject,
    readp = offset_on_read,
    -length_of_subject,
    -length_of_snp,
    readfp = start_match_of_read,
    readlp = end_match_of_read,
    dir = match_direction) %>%
  mutate(name = gsub("-1073bis", "", name))

#' J'ai déterminé les positions des SNP qui nous intéressent dans les
#' deux variables suivantes ^[Le code suivant aurait pu inclure les
#' néomutations. Mais à priori, il n'y en a pas.].

snppos_sw <- filter(snp, mutant == "sw") %>%
  select(refp) %>%
  distinct() %>%
  unlist() %>%
  as.vector()
snppos_ws <- filter(snp, mutant == "ws") %>%
  select(refp) %>%
  distinct() %>%
  unlist() %>%
  as.vector()


#' # Observations générales
#'
#' ## Nombres de reads par transformation

snp %>%
  group_by(read, mutant) %>%
  summarise(count = n()) %>%
  group_by(mutant) %>%
  summarise(count = n()) %>%
  knitr::kable(col.names = c("Transformant", "Nombre de read"), align = "c")

#' ## Nombre de SNP par transformation

snp %>%
  group_by(mutant) %>%
  summarise(count = n()) %>%
  knitr::kable(col.names = c("Transformant", "Nombre de SNP"), align = "c")

#' ## Distribution du nombre de SNP

snp %>%
  group_by(read, mutant) %>%
  summarise(count = n()) %>%
  ggplot(aes(x = count)) +
  geom_density(adjust = 0.4, fill = "gray", alpha = 0.5) +
  labs(x = "Nombre de SNP",
       y = "Densité",
       title = "Distribution du nombre de SNP" )

#' ## Distribution de la qualité des SNP
#'
#' J'ai regardé globalement la distribution de la qualité des SNPs.

,#+ qual1, fig.margin=TRUE
qplot(data = snp, base_q, geom = "density",
      xlab = "Qualité de la base", ylab = "",
      main = "Distribution de la qualité")

#' Si on regarde par globalement comment évolue la qualité des SNPs par séquence :

,#+ qual2, fig.margin=TRUE
snp %>%
  ggplot(aes(x = refp, y = base_q, color = base_q)) +
  geom_line(aes(group = read), alpha = 1/5) +
  geom_point(alpha = 1/10, size = 1/10) +
  scale_color_viridis(begin = 0, end = 0.8) +
  geom_segment(aes(x = max(refp), xend = max(refp) - 20, y = 41.2, yend = 41.2),
               arrow = arrow(length = unit(0.1, "cm")),
               color = "red") +
  annotate("text", x = 668, y = 41.4, label = "1073", size = 2, color = "red") +
  labs(x = "Position", y = "Qualité",
       title = "Évolution de la qualité\nau long de la séquence")

#' Si on regarde cette qualité par séquence :

,#+ qual3, cache=TRUE, fig.width=15, fig.height=7, fig.fullwidth=TRUE
snp %>%
  ggplot(aes(x = refp, y = base_q)) +
  geom_point(alpha = 1/5, size = 0.1) +
  geom_line(alpha = 1) +
  facet_wrap( ~ name) +
  theme(strip.background = element_blank(),
        strip.text = element_text(size= 6),
        axis.text = element_text(size = 5),
        panel.margin = unit(0.1, "lines")) +
  labs(x = "Position", y = "Qualité", title = "Qualité par position\n par séquence")

#' La qualité diminue en fin de séquence. C'est masqué pour l'instant
#' par le fait que j'ai artificiellement appelé N les bases d'une
#' qualité inférieure à $X$ .

#' # Répartition des SNP sur les séquences
#'
#' J'ai voulu regarder globalement la distribution des SNP sur les
#' séquences.

,#+ repar, cache=FALSE, fig.margin=TRUE, fig.cap="La distribution des SNP en fréquence"
snp %>%
  ggplot(aes(x = refp, fill = mutant )) +
  geom_histogram(binwidth = 10) +
  facet_grid(mutant~.) +
  labs(x = "Position", y = "")

,#+ repar2, cache=FALSE, fig.margin=FALSE, fig.cap="La distribution des SNP en densité"
snp %>%
  ggplot(aes(x = refp, fill = mutant )) +
  geom_density(aes(group = mutant), adjust = 1/3, alpha = 1/2) +
  geom_vline(xintercept = snppos_sw, alpha = 0.1) +
  labs(x = "Position",
       y = "Densité",
       title = "Distribution des SNPs sur les reads",
       fill = "Transformant") +
  theme(panel.grid.major.x = element_blank(),
        legend.position = c(0.8, 0.8))

#' ## Définition des transitions

#' J'ai défini une fonction qui permet de déterminer le type de
#' mutation, de strong à weak (`sw`), de weak à strong (`ws`) ou
#' autre.

## #' une fonction qui définit le type de transition, de la référence
## #' à la séquence observée.
find_transition <- function(ref, base) {
  stopifnot(typeof(ref) == "character", typeof(base) == "character")

  is_W <- function(base) ifelse(base == "A" || base == "T", TRUE, FALSE)
  is_S <- function(base) ifelse(base == "C" || base == "G", TRUE, FALSE)

  if      (is_W(ref) & is_S(base)) "ws"
  else if (is_S(ref) & is_W(base)) "sw"
  else if (is_S(ref) & is_S(base)) "ss"
  else if (is_W(ref) & is_W(base)) "ww"
  else stop("Base ", ref, " or base ", base, " is not a DNA base.",
            call. = FALSE)
}

#' J'ai d'abord regardé si on avait des SNPs improbables, *ie* des
#' mutations de W à W (`ww`) ou de S à S (`ss`).

snp %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  filter(trans %in% c("ss", "ww")) %>%
  print()

#' Il n'y en a pas. Plutôt une bonne nouvelle !
#'
#' ## Distribution par type de mutation
#'
#' J'ai voulu voir si les mutations S->W et les mutations W->S étaient
#' réparties différemment sur les séquences.

snp %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  ggplot(aes(x = refp, fill = trans)) +
  geom_density(adjust = 1/3, alpha = 1/2) +
  geom_vline(xintercept = snppos_sw, alpha = 0.1) +
  theme(panel.grid.major.x = element_blank()) +
  labs(x = "Position",
       y = "Densité",
       fill = "Mutation",
       title = "Distribution des mutations") +
  legend_position(0.8, 0.8)

snp %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  ggplot(aes(x = refp )) +
  geom_histogram(aes(fill = trans, color = trans), binwidth = 10,
                 position = "dodge" ) +
  labs(x = "Position", y = "",
       title = "Distribution des mutations",
       fill = "mutation",
       color = "mutation") +
  legend_position(0.75, 0.85)

#' # Trace de conversion
#'
#' ## Distribution de la longueur
#'
#' J'ai ensuite regardé comment étaient réparties les longeurs de
#' trace de conversion sur les séquences.
#'
snp %>%
  group_by(read) %>%
  summarise(max = max(refp)) %>%
  ggplot(aes(x = max)) +
  geom_histogram(binwidth = 10) +
  labs(x = "Longueur de trace de conversion",
       y = "",
       title = "Distribution de la longueur\nde trace de conversion" )

#' ##
#'

snp %>%
  group_by(read, mutant) %>%
  summarise(max = max(refp)) %>%
  inner_join(x = snp, y = .) %>%
  filter(refp == max) %>%
  ggplot(aes(x = refp)) +
  geom_histogram(binwidth = 10)


#' À première vue, le dernier SNP est souvent dans la partie 3' du
#' gène. Cette distribution là n'est pas celle qu'on avait avec les
#' séquences W et S.
#'
#' J'ai donc voulu voir s'il y avait une différence de longueur de
#' trace de conversion entre les séquences de SW et les séquences WS,
#' dans un premier temps en fréquence, puis en densité.

snp %>%
  group_by(read, mutant) %>%
  summarise(max = max(refp)) %>%
  ggplot(aes(x = max)) +
  geom_histogram(aes(fill = mutant), position = "dodge") +
  labs(fill = "Transformant", x = "Longueur de conversion tract", y = "") +
  ggtitle( "Distribution de la\nlongueur de trace de conversion")

snp %>%
  group_by(read, mutant) %>%
  summarise(max = max(refp)) %>%
  ggplot(aes(x = max, fill = mutant, color = mutant)) +
  geom_density(adjust = 1/3, alpha = 0.5) +
  labs(y = "Densité", x = "Position du point de basculement",
       title = "Position du point de basculement") +
  theme(legend.position = c(0.2, 0.81))

#' J'ai voulu voir si le point de switch était plus souvent à un SNP
#' strong que weak.

snp %>%
  group_by(read, mutant) %>%
  summarise(max = max(refp)) %>%
  inner_join(x = snp, y = .) %>%
  filter(refp == max) %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  ggplot(aes(x = max)) +
  geom_histogram(aes(fill = trans, color = trans), position = "dodge", binwidth = 10) +
  legend_position(0.2, 0.3) +
  labs(x = "Position du point de basculement",
       y = "",
       fill = "Mutation",
       color = "Mutation",
       title = "Type de mutation au point de switch") +
  facet_grid( mutant ~ .)

#' # En(-)quête de néo-mutations…
#'
#' J'ai voulu voir si on retrouvait les néomutations du séquençage
#' précédent dans la trace de conversion. Le problème c'est que cette
#' fois la distribution du nombre de SNP à une position donnée ne
#' permet pas de discriminer facilement les positions de SNP calibré
#' avec les néo-mutations. J'ai donc décidé de ne regarder que les
#' positions où le nombre de SNP est de 1, en supposant qu'elles
#' incluent les positions de néo-mutation.
#'

snp %>%
  group_by(refp) %>%
  summarise(count = n()) %>%
  filter(count == 1) %>%
  print()

#' En clair, il n'y a pas de position où on ne retrouve qu'un
#' SNP. Donc si néo-mutation il y a, elle occasionne dans au moins
#' deux séquences différentes un même SNP. Ce qui est peu probable.

,#+ nombresnp, fig.margin = TRUE
snp %>%
  group_by(refp) %>%
  summarise(count = n()) %>%
  ## (X) filter(count < 5) %>%
  ggplot(aes(x = count)) +
  geom_histogram(binwidth = 1) +
  geom_vline(xintercept = 5, color = "red") +
  annotate("text", label = "x = 5", color = "red", x = 8, y = -0.1) +
  labs(x = "Nombre de SNP",
       y = "",
       title = "Distribution du nombre de SNP par position")

#' En fait aucune position de SNP calibrée ne génère moins de 5
#' mutations. On peut donc en conclure qu'il n'y a pas de néomutations
#' dans cette manip.

## (X) #' [ ] échantillonne autant de positions aléatoirement dans les
## (X) #' groupes sw et ws. $856$ est le nombre de positions maximum pour
## (X) #' équilibrer le plan.
## (X) #'
## (X) #'
## (X) #+ wip, echo=FALSE

## (X)                                         # WIP
## (X) snp %>%
## (X)   rowwise() %>%
## (X)   mutate(trans = find_transition(refb, readb)) %>%
## (X)   ungroup() %>%
## (X)   group_by(mutant) %>%
## (X)   ## (X) filter(base_q > 40 ) %>%
## (X)   sample_n(856, FALSE) %>%              # échantillonne autant de positions dans les deux groupes.
## (X)   ggplot(aes(x = refp, fill = trans )) +
## (X)   geom_histogram(position = "dodge", binwidth = 10) +
## (X)   ## geom_density(aes(group = mutant), adjust = 1/5, alpha = 1/2) +
## (X)   legend_position(0.8, 0.8)

## (X) sapply(1:10, function(i) snp %>% group_by(mutant) %>% sample_n(856) )

## (X)                                         # END WIP

## (X) ## (X) test_snp <- apply(
## (X) ## (X)   sapply(1:3, function(i) snp %>% group_by(mutant) %>% sample_n(856)),
## (X) ## (X)   2, as_data_frame
## (X) ## (X) )

## (X) ## (X) test_snp[[1]]

## (X) snp %>%
## (X)   group_by(read, mutant) %>%
## (X)   summarise(max = max(refp)) %>%
## (X)   inner_join(x = snp, y = .) %>%
## (X)   filter(refp == max) %>%
## (X)   rowwise() %>%
## (X)   mutate(trans = find_transition(refb, readb)) %>%
## (X)   ggplot(aes(x = max)) +
## (X)   geom_histogram(aes(fill = trans, color = trans), position = "dodge", binwidth = 10) +
## (X)   ## legend_position(0.2, 0.5) +
## (X)   labs(x = "Position du point de basculement",
## (X)        y = "",
## (X)        fill = "Mutation",
## (X)        color = "Mutation",
## (X)        title = "Type de mutation au point de switch") +
## (X)   facet_grid( mutant )
#+END_SRC

* SNP calling précis [0%]

** phred + muscle = phruscle !
Le SNP calling via ssahaSNP ne permet pas de connaître l'ensemble des
informations dont on a besoin. Un peu dans l'esprit de polySNP, je
veux écrire un script python qui permette :

1. de lancer phred sur la séquence abi en entrée.
2. de lancer muscle avec pour entrée le fichier d'alignement fst entre
   le gène synthétique et la séquence sauvage d'une part, et la
   séquence dans le fichier seq d'autre part.
3. d'analyser la sortie de phred .phd pour extraire l'information de
   la qualité de la base.

Étant donné le nombre de séquence faible, j'ai fait le choix de lancer
muscle à chaque séquence. Une façon plus efficace de faire la même
chose serait d'aligner l'ensemble des séquences SNP WS d'un coup, avec
leur référence, mais c'est un peu plus compliqué à programmer.

- [ ] manage paths mistake. le script fonctionnait bien quand l'input était dans
  le dossier de travail. Mais il faut tenir compte des changements de dossier de
  travail pour faire les choses bien. 

#+BEGIN_SRC python :tangle src/phruscle.py
# -*- coding: utf-8 -*-

# 1. lancer phred sur la séquence abi en entrée.
# 2. lancer muscle avec pour entrée le fichier d'alignement fst entre
#    le gène synthétique et la séquence sauvage d'une part, et la
#    séquence dans le fichier seq d'autre part.
# 3. analyser la sortie de phred .phd pour extraire l'information de
#    la qualité de la base.

from Bio import AlignIO  # permet d'analyser les sorties de muscle.
from Bio import SeqIO  # permet de tester les entrées
import subprocess as sub  # permet de lancer phred et muscle
import click
import os.path
import numpy as np
import pandas as pd


def is_abi(sequence):
    """Cette fonction détermine si une séquence est bien un fichier spectrogramme.
    Renvoit TRUE ou FALSE."""
    assert os.path.isfile(sequence), "Le fichier n'existe pas."

    with open(sequence,
              "rb") as input:  # le fichier doit être ouvert en mode "rb"
        if len(SeqIO.read(
                input,
                "abi").id) > 0:  # teste la longueur de l'id de la séquence
            return True
        else:
            return False


def is_fasta(sequence):
    """Cette fonction détermine si une séquence est bien un fichier fasta.
    Renvoit True ou False."""
    assert os.path.isfile(sequence), "Le fichier n'existe pas"

    with open(sequence, "rb") as input:
        seq_list = []
        for record in SeqIO.parse(input, "fasta"):
            seq_list.append(len(record.id))  # crée une liste de longueur d'id.

    if 0 not in seq_list:  # s'il n'y a pas d'identifiant nul
        return True  # c'est bon.
    else:
        return False


def run_phred(input, cutoff):
    """Cette fonction utilise phred sur la séquence .abi en entrée.
    Test: entrée de type abi."""
    assert is_abi(input), "La séquence n'est pas un fichier de sequençage."

    # phred reads and process file listed in the file input via `-if`.
    # we must then create a temporary file containing only the name of the input.
    with open('tempfile', 'w') as tempfile:
        tempfile.write(input + "\n")

    # subprocess.call takes a list of argument as input.
    # the following list describes the phred list of argument.
    phred = [
        "phred",
        "-st",
        "fasta",  # sequence type output (default = fasta)
        "-trim_alt",
        "\"\"",  # quality trim
        "-trim_cutoff",
        str(cutoff),  # error probability of trimming
        "-trim_fasta",  # trim sortie fasta.
        "-trim_phd",  # trim sortie phd
        "-s",  # write seq file, append ".seq" to the names of the input files
        "-d",  # write a poly file
        "-p",  # write a phd file
        "-if",
        "tempfile"  # input file
    ]
    phred_call = sub.call(phred)
    os.remove("tempfile")  # supprime le fichier temporaire
    return phred_call


def run_muscle(input, reference):
    """Cette fonction lance muscle sur la séquence fasta en entrée.
    Test: entrée de type fasta."""
    assert is_fasta(reference), "La référence n'est pas un fichier fasta."
    assert is_fasta(input), "La séquence n'est pas un fichier fasta."

    muscle = [
        "muscle",
        "-quiet",  # non verbose
        "-profile",  # do not disrupt the profile alignment
        "-objscore",
        "ps",  # matrice de scoring
        "-maxmb",
        str(100),  # 1.5 G as max memory
        "-in1",
        input,
        "-in2",
        str(reference),  # profile is reference
        "-out",
        input + ".aln"  # append .aln to input name
    ]

    muscle_call = sub.call(muscle)  # call muscle on input
    return muscle_call  # return 0 or 1 if muscle is successful.


@click.group()
def phruscle():
    """This program gather a set of function to run phred on a abi file, to run muscle on the
    called bases, and to give a nicely formatted output either as human readable or as csv.

    """
    pass


@phruscle.command('basecall', short_help='Make basecall and alignment.')
@click.option('-c',
              '--cutoff',
              default=0.05,
              help="Probability of error of basecalling")
@click.option('-i', '--input', help="The abi sequence to base call")
@click.option('-r', '--ref', help="The reference alignment in fasta format")
def run_phruscle(input, ref, cutoff):
    """This programme uses phred to call bases on the `--input` file to create a fasta file.
    Muscle align this fasta file to the `--reference`, without disrupting the reference,
    to get the localisation of SNPs and their polarity.

    """
    phred_code = run_phred(input, cutoff)
    muscle_input = os.getcwd() + '/' + os.path.basename(input) + '.seq'

    if phred_code == 0:
        run_muscle(muscle_input, ref)  # FIXME fragile.
        ## Il faut que la séquence input soit dans le dossier de travail. peut être voir à
        ## jouer sur la sortie de phred.
    else:
        print "Phred failed."


def parse_muscle(align):
    """Cette fonction renvoit un dict comprenant 3 choses :
    1. la séquence alignée
    2. la séquence sauvage
    3. la séquence avec les SNP
    """
    align = os.getcwd() + '/' + os.path.basename(input) + '.seq.aln'
    assert is_fasta(align), "Le fichier n'est pas un fichier fasta"

    def read_seq(sequence, index):
        return AlignIO.read(sequence, "fasta")[index]

    return {
        'exp': str(read_seq(align, 0).seq),  # la séquence expérimentale
        'wt': str(read_seq(align, 1).seq),  # la séquence sauvage.
        'snp': str(read_seq(align, 2).seq)  # la séquence du gène synthétique
    }


def are_the_same(exp, snp, wt):
    """Détermine si les trois bases sont identiques. Renvoit `.` quand les trois bases sont
    identiques, `x` quand la base exp est la base `snp`, `X` quand la base exp est la base
    wt, et '-' quand la base exp ne correspond à aucune des possibilités

    """
    if exp == '-':  # si la base a été trimmée ou non alignée
        return '-'
    elif exp == snp and snp == wt:  # si les trois bases sont identiques
        return '.'
    elif exp == snp and snp != wt:  # si la base correspond au SNP
        return 'x'
    elif exp != snp and exp == wt:  # si la base correspond au WT
        return 'X'
    else:
        return '-'  # si c'est encore autre chose ?


def index_seq(sequence):
    """Détermine la position dans la séquence expérimentale"""

    position = 0
    position_list = []
    for index, base in enumerate(sequence):
        if base != '-': position += 1
        position_list.append(str(position))

    return position_list


def polarity_snp(align):
    """Détermine la polarité des SNP, WT ou GS."""
    muscle_output = parse_muscle(align)

    consensus = []
    for i, base in enumerate(muscle_output['exp']):
        exp = muscle_output['exp'][i]
        snp = muscle_output['snp'][i]
        wt = muscle_output['wt'][i]

        consensus += are_the_same(
            exp, snp, wt)  # + ',' + exp + '\n' # + sortie de parse_phd

    return consensus


def parse_phd(align):
    """Renvoit une DataFrame à partir de la sortie phd de phred.

    """
    return pd.read_table(align,
                         sep=" ",
                         skiprows=20, # FRAGILE. peut être utiliser une autre fonction
                         # pour définir où commence la séquence, ou pour
                         # nettoyer la sortie phd de phred
                         skipfooter=3, # idem, moins sensible normalement.
                         engine='python', # nécessaire pour skipfooter
                         names=['base', 'qual', 'phase']) # 'phase' est la position dans
    # le spectrogramme.


@phruscle.command('table', short_help="Make a table of SNP qual and polarity")
@click.option('-i', '--input', help="Input file in abi format")
@click.option('-o',
              '--output',
              type=click.File('wb'),
              default='-',
              required=False,
              help="Output file in csv format")
def clean_output(input, output):
    """"""
    assert is_abi(input), "Input is not an abi file"

    parse_align = parse_muscle(input) # + ".seq.aln")

    clean_data = pd.DataFrame({
        'seqp': index_seq(parse_align['exp']),
        'refp': index_seq(parse_align['wt']),
        'cons': polarity_snp(input + ".seq.aln")
    })

    with_phd = pd.concat(
        [
            clean_data[clean_data.cons != '-'].reset_index(
                drop=
                True),  # ne garde que les positions qui existent dans le phd file
            parse_phd(input + ".phd.1")
        ],
        axis=1,
        ignore_index=True)
    with_phd.columns = ['cons', 'refp', 'seqp', 'base', 'qual', 'phase']

    if output != '-':
        with_phd.to_csv(output, index=False)
    else:
        click.echo(with_phd, file=output)
#+END_SRC

Le script suivant est un script pour déployer =phruscle=.

#+BEGIN_SRC python :tangle setup.py
from setuptools import setup, find_packages

setup(name="phruscle",
      version="0.0.1",
      py_modules=["phruscle"],
      packages=find_packages('src'),
      package_dir={'': 'src'},
      install_requires=[
          'Click',
          'Biopython',
          'numpy',
          'pandas',
      ],
      entry_points='''
        [console_scripts]
        phruscle=phruscle:phruscle
    ''', )
#+END_SRC
Le script est là : [[./src/phruscle]].

Avec la commande suivante :
#+BEGIN_SRC sh
phruscle table -i pW85-1073.ab1 -o test.csv
#+END_SRC

Je produit une table csv, que j'analyse rapidement dans R.

#+BEGIN_SRC R :file tmp/test_qual.pdf :results output graphics
library(dplyr)
library(ggplot2)

setwd("./tmp")
test <- read.csv("test.csv") %>% tbl_df()

test %>%
  qplot(data= ., x = refp, y = qual, geom = c("point", "line"), color = qual)
#+END_SRC

#+RESULTS:
[[file:tmp/test_qual.pdf]]

À priori tout est bon. Le but est maintenant d'utiliser ce script sur un grand
nombre de séquence.

** phruscling et autres joyeusetés…

Le script phruscle est pour l'instant suffisamment fonctionnel pour qu'on puisse
l'utiliser sur l'ensemble des séquences ab1 dont on dispose. Il faut auparavant
recréer l'alignement entre la séquence sauvage et la séquence snp de WS et SW.

*** alignement WS et SW

J'utilise muscle pour faire l'alignement entre la séquence sauvage et les
séquences SW et WS.

#+BEGIN_SRC sh :tangle src/make_ref :shebang "#!/usr/bin/env bash"
muscle \
    -profile \
    -in1 raw/ref/strong-weak.fasta \
    -in2 raw/ref/reference1073bis-1392.fasta \
    -out raw/ref/aln-sw-ref.fst

muscle \
    -profile \
    -in1 raw/ref/weak-strong.fasta \
    -in2 raw/ref/reference1073bis-1392.fasta \
    -out raw/ref/aln-ws-ref.fst
#+END_SRC

*** run phruscle on it

#+BEGIN_SRC sh :results none :shebang "#!/usr/bin/env bash" :tangle src/phruscler

ROOT=`pwd`

mkdir data/ws/aln
cd data/ws/aln

for file in ../spectro/*.ab1
do
    phruscle basecall -i $file -r $ROOT/raw/ref/weak-strong.fasta
done
#+END_SRC

* Tests

La fonction /assert/ provient de là :
[[http://tldp.org/LDP/abs/html/debugging.html#ASSERT]]

Le script en question vient de là : https://github.com/lehmannro/assert.sh

#+BEGIN_SRC sh
wget https://raw.github.com/lehmannro/assert.sh/v1.1/assert.sh -O test/assert.sh
chmod +x test/assert.sh
#+END_SRC

Le script pour tester les résultats, via =make test=.

#+BEGIN_SRC sh :tangle test/test.sh
  #!/bin/bash

  # cette fonction renvoit le nombre de séquence dans un fichier fastq poolé.
  # elle divise le nombre de ligne par 4 pour connaître le nombre de séquence.
  check_fastq_length () {
      cat $1 | echo $((`wc -l` / 4))
  }

  set -e

  . ./test/assert.sh

  # vérifie qu'il y ait bien 95 séquence dans le fastq SW et 96 dans le fastq WS
  assert "echo `check_fastq_length data/sw/sw_untrimmed.fastq`" "95"
  assert "echo `check_fastq_length data/ws/ws_untrimmed.fastq`" "96"

  # vérifie qu'yl y ait bien 95 séquences dans le fastq SW trimmé et 96
  # dans le fastq WS trimmé
  assert "echo `check_fastq_length data/sw/sw_untrimmed.fastq.trim`" "90"
  assert "echo `check_fastq_length data/ws/ws_untrimmed.fastq.trim`" "90"
  assert "echo `wc -l data/snp_call/snp_calling.dat | awk '{print $1}'`" "1875"

  assert_end results
#+END_SRC

* Dépendances
** BBmap
Le site de téléchargement est là :
https://sourceforge.net/projects/bbmap

Pour installer bbduk :

#+BEGIN_SRC sh
  wget https://sourceforge.net/projects/bbmap/files/latest/download \
       -o bin/bbmap.tar.gz
  cd bin
  tar xzf bin/bbmap.tar.gz
#+END_SRC

** R markdown
Il faut une version récente du package =rmarkdown=.

#+begin_src R :tangle no
install.package('rmarkdown', type = "source")
#+end_src

* Config                                                           :noexport:

#+title: Séquençage WS et SW

Ce dossier contient les séquences des plaques obtenues avec les
constructions SW et WS, envoyées à séquencer le [2016-03-15 Tue].

* Dossiers et fichiers
Les données brutes au format .zip sont dans le dossier =raw=. Elles
sont extraites dans le dossier =data=, séparé en =ws= et =sw= pour les
analyses. Rien ne doit toucher au dossier =raw=.

J'ai ensuite utilisé le script [[./src/sort_into_dir.sh]] pour classer les
fichiers selon leur extension.

#+BEGIN_SRC sh :tangle src/sort_into_dir.sh
#!/bin/bash

cd data/ws

mkdir fasta spectro seq

find . -name "*.fas"  -maxdepth 1 -exec mv {} ./fasta/ \;
find . -name "*.ab1"  -maxdepth 1 -exec mv {} ./spectro/ \;
find . -name "*.seq"  -maxdepth 1 -exec mv {} ./seq/ \;
find . -name "*.csv"  -maxdepth 1 -exec mv {} ../csv/ \;

cd ../sw

mkdir fasta spectro seq

find . -name "*.fas"  -maxdepth 1 -exec mv {} ./fasta/ \;
find . -name "*.ab1"  -maxdepth 1 -exec mv {} ./spectro/ \;
find . -name "*.seq"  -maxdepth 1 -exec mv {} ./seq/ \;
find . -name "*.csv"  -maxdepth 1 -exec mv {} ../csv/ \;
#+END_SRC

* Contrôle qualité
Après avoir reçu les séquences, j'ai voulu connaître la qualité
globale des séquences. Je les ai donc converties en fastq avec le
script [[./src/ab1_to_fastq.sh]], et j'ai utilisé ~fastqc~ pour
représenter la qualité globale via le script [[./src/quality_control.sh]].

#+BEGIN_SRC sh :tangle src/ab1_to_fastq.sh
#!/bin/bash

# transforme en fastq
cd data/ws

touch ws_untrimmed.fastq

for file in spectro/*.ab1
do
    seqret \
        -sformat abi \
        -osformat fastq \
        -auto \
        -stdout \
        -sequence $file \
        >> ws_untrimmed.fastq
done

cd ../sw

# TEMPORAIRE, élimine le fichier .ab1 tendancieux pour l'instant
# rm spectro/psw76-1073bis.ab1

touch sw_untrimmed.fastq

for file in spectro/*.ab1
do
    seqret \
        -sformat abi \
        -osformat fastq \
        -auto \
        -stdout \
        -sequence $file \
        >> sw_untrimmed.fastq
done
#+END_SRC

J'ai utilisé ~fastqc~ pour représenter la qualité globale via le
script [[./src/quality_control.sh]].

#+BEGIN_SRC sh :tangle src/quality_control.sh
#!/bin/bash

# contrôle qualité des séquences.
cd data

# crée un dossier qc de quality control pour ws et sw
mkdir -p qc/{ws,sw}

# fastqc sortie dasn le dossier approprié
fastqc ws/ws_untrimmed.fastq -o qc/ws
fastqc sw/sw_untrimmed.fastq -o qc/sw

# transfert du fichier .png qui nous intéresse dans le dir adapté
# et suppression des dossiers inutiles
#' -qq : very quiet
#' -o  : overwrite without warning
#' -d  : out dir
unzip -qq -o \
      qc/sw/sw_untrimmed_fastqc.zip \
      sw_untrimmed_fastqc/Images/per_base_quality.png \
      -d ../anl/ \
    && mv ../anl/sw_untrimmed_fastqc/Images/per_base_quality.png \
          ../anl/sw_per_base_qual.png \
    && rm -r ../anl/sw_untrimmed_fastqc

# transfert du fichier .png qui nous intéresse dans le dir adapté
# et suppression des dossiers inutiles
unzip -qq -o \
      qc/ws/ws_untrimmed_fastqc.zip \
      ws_untrimmed_fastqc/Images/per_base_quality.png \
      -d ../anl/ \
    && mv ../anl/ws_untrimmed_fastqc/Images/per_base_quality.png \
          ../anl/ws_per_base_qual.png \
    && rm -r ../anl/ws_untrimmed_fastqc
#+END_SRC

À priori les séquences sont plutôt de bonne qualité. Voir le résumé
dans le fichier [[./data/qc/sw/sw_untrimmed_fastqc.html]] et
[[./data/qc/ws/ws_untrimmed_fastqc.html]].

* Analyse rapide du SNP calling de GATC
J'ai rapidement analysé la sortie du SNP calling effectué par GATC,
mais il manque des données. Je vais refaire le SNP calling moi-même,
en utilisant dans un premier temps ssaha2.

#+BEGIN_SRC R :tangle anl/gatc_snpcall/snp_call.r :exports none
  #' ---
  #' title: "Rapide analyse des SNP"
  #' author: "Samuel BARRETO"
  #' date: "31 janvier 2016"
  #' output:
  #'   html_document:
  #'     highlight: tango
  #'     theme: paper
  #'     code_folding: hide
  #'     toc: true
  #'     toc_depth: 2
  #'     toc_float: true
  #' ---

  #' # Lecture des données
  #'
  #' Les données sont les tableurs de snp calling que GATC nous a fait
  #' gratuitement. Ce script n'est que préliminaire, je referai le snp
  #' calling comme il faut par la suite.
  library(dplyr)
  library(ggplot2)
  library(readr)
  library(viridis)

  #' Lecture des données et combinaison dans un seul tableur.
  ws <- read_delim("../../data/csv/1582203.SNP.csv", delim = ";")
  sw <- read_delim("../../data/csv/1582443.SNP.csv", delim = ";")
  ws$type <- "ws"
  sw$type <- "sw"

  #' ## Définition des transitions
  #'
  ## #' une fonction qui définit le type de transition, de la référence
  ## #' à la séquence observée.
  find_transition <- function(ref, base) {
    stopifnot(typeof(ref) == "character", typeof(base) == "character")

    is_W <- function(base) ifelse(base == "A" || base == "T", TRUE, FALSE)
    is_S <- function(base) ifelse(base == "C" || base == "G", TRUE, FALSE)

    if (is_W(ref) & is_S(base)) "ws"
    else if (is_S(ref) & is_W(base)) "sw"
    else if (is_S(ref) & is_S(base)) "ss"
    else if (is_W(ref) & is_W(base)) "ww"
    else stop("Base ", ref, " or base ", base, " is not a DNA base.",
              call. = FALSE)
  }

  data <- rbind(ws, sw) # lie les deux jeux de données
                                          # change les noms de colonne
  colnames(data) <-  c("ref", "pos", "ref.base", "alt.base", "qual",
                       "query", "qpos", "qlen", "type")
                                          # supprime le nom de l'amorce
  data <- mutate(data, query = gsub("-1073bis", "", query))

  ## ggplot default theme
  theme_set(theme_minimal(base_size = 10, base_family = "Courier"))

  #' # Distribution des SNP
  #' Je regarde la distribution des SNP sur les séquences
                                          ,#+distrisnp
  data %>%
    ggplot(aes(x = pos, fill = type)) +
    geom_histogram(binwidth = 10) +
    facet_grid(type~.) +
    xlab("Position sur la reference") +
    ylab("Nombre de SNP")

  #' ## Alignement des séquences
  #'
  #' Je fais rapidement un petit alignement des séquences
  #'
  data %>%
    ggplot(data = ., aes(x = pos, y  = query )) +
    ## geom_text(aes(label = alt.base)) +
    geom_point(aes(color = alt.base), alpha = 0.4)

  data %>%
    group_by(query) %>%
    summarise(end.tc = max(pos)) %>%
    ggplot(aes(x = end.tc)) +
    geom_histogram()

  data %>% select(query) %>% unique()

  #' ## Problème avec les séquences
  #'
  #' Il n'y a que 127 séquences analysées dans ce tableau. Ça ne va pas.
  #' On devrait s'attendre à 192 séquences normalement. Il manque du
  #' signal. Je vais faire l'analyse moi-même.

  data %>%
    select(query) %>%
    unique()
#+END_SRC

Le script est là [[./anl/gatc_snpcall/snp_call.r]], les sorties en
html là [[./anl/gatc_snpcall/snp_call.html]].

* SNP calling global
** trimming des séquences

J'ai utilisé le programme bbduk pour trimmer les séquences de faible
qualité.

#+BEGIN_SRC sh :tangle src/qtrim.sh
  #!/bin/bash

  #' -qtrim=rl : quality trim right and left
  #' -trimq=28 : trim if quality < 28 (sanger encoding, illumina 1.9)
  #' -minlen=620 : keep only seq with length > 620, after trimming.
  #' -Xmx1g : tells bbduk / java to use 1G of RAM

  FASTQ="data/sw/sw_untrimmed.fastq
  data/ws/ws_untrimmed.fastq
  "

  for f in $FASTQ
  do
      out=$f.trim
      bin/bbmap/bbduk.sh -Xmx1g \
                         -in=$f \
                         -out=$f.qtrim \
                         -qtrim=rl \
                         -trimq=28 \
                         -minlen=600

      ## convertit les bases d'une qualité inférieure à 20 en N.
      seqtk seq \
            -q20 \
            -nN \
            $f.qtrim > $out

      ## convertit le fastq en fasta
      seqret \
          -sformat fastq \
          -osformat fasta \
          -auto -stdout \
          -sequence $out > $f.fasta

      rm $f.qtrim
  done
#+END_SRC

** Contrôle qualité des séquences trimmées

#+begin_src sh :tangle src/qtrim_qc.sh
  #!/usr/bin/env bash

  cd data

  TRIM="ws/ws_untrimmed.fastq.trim sw/sw_untrimmed.fastq.trim"

  mkdir qtrim_qc

  for f in $TRIM
  do
      fastqc $f -o qtrim_qc
  done
#+end_src

Le script est là [[./src/qtrim_qc.sh]] et les sorties sont là
[[file:data/qtrim_qc/sw_untrimmed.fastq.trim_fastqc.html][./data/qtrim_qc/sw_untrimmed.fastq.trim_fastqc.html]] et là
[[file:data/qtrim_qc/sw_untrimmed.fastq.trim_fastqc.html][./data/qtrim_qc/ws_untrimmed.fastq.trim_fastqc.html]].

Les séquences sont nettement raccourcies par rapport aux séquences non trimmées. Mais l'ensemble des
bases qu'on veut analyser sont de bonne qualité. C'est donc plutôt bon signe.

** Pooling des séquences dans un seul fastq

#+BEGIN_SRC sh :tangle src/pool_trim.sh
  #!/usr/bin/env bash

  cat data/sw/sw_untrimmed.fastq.trim data/ws/ws_untrimmed.fastq.trim > data/trimmed.fastq
#+END_SRC

[[./src/pool_trim.sh]]

** Analyses des alignements via seaview
Pour les analyses dans seaview, il faut un fichier fasta. Je lui
ajoute la référence.

#+BEGIN_SRC sh :tangle src/trim_to_fasta.sh
#!/usr/bin/env bash

seqret -sformat fastq -osformat fasta -auto -stdout \
       -sequence data/trimmed.fastq > data/trimmed.fasta

fastx_reverse_complement \
    -i raw/ref/reference1073bis-1392.fasta \
    >> data/trimmed.fasta

#+END_SRC

[[.src/trim_to_fasta.sh]]

J'ai placé les différentes analyses graphiques via seaview dans le
dossier [[./anl/align]].

Différents alignements :
- l'alignement global : [[anl/align/trimmed.mase][anl/align/trimmed.mase]]
- l'alignement avec seulement les sites variables : [[anl/align/variable_site.mase]]

Sur l'alignement global, j'ai repéré quelques cas de traces complexes,
où des séquences avaient ‘gardé’ leur allèle sauvage, quand les deux
SNP environnants sont les SNP transformants.

** snp calling via ssahaSNP

Pour installer ssahaSNP voir les instructions là :
ftp://ftp.sanger.ac.uk/pub/resources/software/ssahasnp/.

Il est très important que les fichiers fasta de référence soit formattés de la
bonne façon, sinon ssahaSNP ne sort pas les bonnes valeurs dans les lignes de
tableau.

#+begin_src sh :tangle src/snp_call.sh
   #!/usr/bin/env bash

   # Variant calling using ssaha2 and ssahaSNP

   if [ ! -e data/snp_call ]
   then
       mkdir data/snp_call
   fi

   cd data/snp_call

   if [[ ! -e trimmed.fastq && ! -e ref.fasta ]]
   then
       ln -s    ../trimmed.fastq .
       ln -s ../../raw/ref/reference1073bis-1392.fasta ref.fasta
   fi

   ## alignement à la séquence de référence
   #' -output psl :             format de sortie psl
   #' reference_reverse.fasta : séquence de référence
   #' trimmed.fastq :           séquence à aligner
   #' output.psl :              fichier de sortie
   ../../bin/ssahaSNP/ssaha2 -output psl ref.fasta trimmed.fastq > output.psl

   ## column annotation based on
   ## ftp://ftp.sanger.ac.uk/pub/resources/software/ssahasnp/readme,
   ## part (6) some further information
   # la première ligne du fichier .dat, afin d'être lu dans R
   cat \
       <( echo "match subject_name index_of_subject read_name s_base q_base s_qual q_qual offset_on_subject offset_on_read length_of_snp start_match_of_read end_match_of_read match_direction length_of_subject" ) \
       <( ../../bin/ssahaSNP/ssahaSNP ref.fasta trimmed.fastq | \
                egrep ssaha:SNP | \
                awk '{print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15}') \
       > snp_calling.dat
#+end_src

Le script est là : [[./src/snp_call.sh]].

** création de la table d'identification des clones
Les spectrogrammes contiennent l'info permettant de relier à un
identifiant de séquence le nom expérimental qu'on lui a attribué.

#+BEGIN_SRC python :tangle src/make_id_table.py
  #!/usr/bin/env python

  from Bio import SeqIO
  from glob import glob
  from os.path import basename

  def sw_or_ws(mutant_name):
      """
      Determine si le mutant est SW ou WS
      """
      if 'sw' in mutant_name:
          return 'sw'
      else:
          return 'ws'

  # en tete de colonne
  print "id name mutant"

  def print_seq_id(dna_seq):
      with open(dna_seq, "rb") as spectro:
          sequence = list(SeqIO.parse(spectro, "abi"))
          print sequence[0].id + " " + sequence[0].name + " " + sw_or_ws(sequence[0].name)

  for file in glob("data/sw/spectro/*.ab1"):
      if basename(file) != "psw76-1073bis.ab1": # exclut la sequence qui pose probleme
          print_seq_id(file)

  for file in glob("data/ws/spectro/*.ab1"):
      print_seq_id(file)
#+END_SRC

** Analyses des résultats de snp calling
#+BEGIN_SRC R :tangle anl/snp_call/snp_call.r :exports none
#' ---
#' title: Analyse globale des SNP
#' author: Samuel BARRETO
#' date:
#' output:
#'   tufte::tufte_html:
#'     highlight: tango
#'     toc: true
#'     toc_depth: 2
#' ---


#' # Lecture des données et nettoyage
#'
#' Il faut dans un premier temps lire les données, les nettoyer et associer à
#' chaque séquence la catégorie de plasmide transformeur.
#'
#' La table des identifiants est faite par le script python.
#'

,#+ setup, include=FALSE
library(knitr)
library(tufte)
opts_chunk$set(cache = FALSE, dev = 'png', include = TRUE,
               echo = TRUE, warning = FALSE, error = FALSE,
               message = FALSE)

fte_theme <- function() {
  ## Generate the colors for the chart procedurally with RColorBrewer
  palette <- RColorBrewer::brewer.pal("Greys", n=9)
  color.background = palette[2]
  color.grid.major = palette[3]
  color.axis.text = palette[6]
  color.axis.title = palette[7]
  color.title = palette[9]

  ## Begin construction of chart
  theme_bw(base_size=9) +
    ## Set the entire chart region to a light gray color
    theme(panel.background=element_rect(fill=color.background, color=color.background),
          plot.background=element_rect(fill=color.background, color=color.background),
          panel.border=element_rect(color=color.background),
          panel.grid.major=element_line(color=color.grid.major,size=.25),
          panel.grid.minor=element_blank(),
          axis.ticks=element_blank(),
          ## Format the legend, but hide by default
          legend.position="none",
          legend.background = element_rect(fill = scales::alpha(color.background, 0.3)),
          legend.text = element_text(size=7,color=color.axis.title),
          ## Set title and axis labels, and format these and tick marks
          plot.title=element_text(color=color.title, size=14,
                                  face = "bold", vjust=1.25, hjust = 0),
          axis.text.x=element_text(size=7,color=color.axis.text),
          axis.text.y=element_text(size=7,color=color.axis.text),
          axis.title.x=element_text(size=8, color=color.axis.title, vjust=0, hjust = 0.8),
          axis.title.y=element_text(size=8, color=color.axis.title, vjust = 0.9, angle = 0 ),
          ## Plot margins
          plot.margin = unit(c(0.35, 0.2, 0.3, 0.35), "cm"))
}

legend_position <- function(x, y) theme(legend.position = c(x, y))

,#+ setup2, include = TRUE
library(dplyr)
library(ggplot2)
library(readr)
library(viridis)
library(purrr)
library(ggthemes)

theme_set(theme_bw() + fte_theme())

data_location <- "../../data/snp_call/snp_calling.dat"
id_table_loc <- "../../data/id_table.dat"

#' J'ai relié les données par un `inner_join` sur la base du nom de
#' l'identifiant de la séquence GATC.

snp <- inner_join(
  x = read_delim(file = data_location, delim = " "),
  y = read_delim(file = id_table_loc, delim = " "),
  by=c("read_name" = "id")) %>%
  select(
    -match,
    -subject_name,
    -index_of_subject,
    read = read_name,
    refb = s_base,
    readb = q_base,
    -s_qual,
    base_q = q_qual,
    refp = offset_on_subject,
    readp = offset_on_read,
    -length_of_subject,
    -length_of_snp,
    readfp = start_match_of_read,
    readlp = end_match_of_read,
    dir = match_direction) %>%
  mutate(name = gsub("-1073bis", "", name))

#' J'ai déterminé les positions des SNP qui nous intéressent dans les
#' deux variables suivantes ^[Le code suivant aurait pu inclure les
#' néomutations. Mais à priori, il n'y en a pas.].

snppos_sw <- filter(snp, mutant == "sw") %>%
  select(refp) %>%
  distinct() %>%
  unlist() %>%
  as.vector()
snppos_ws <- filter(snp, mutant == "ws") %>%
  select(refp) %>%
  distinct() %>%
  unlist() %>%
  as.vector()


#' # Observations générales
#'
#' ## Nombres de reads par transformation

snp %>%
  group_by(read, mutant) %>%
  summarise(count = n()) %>%
  group_by(mutant) %>%
  summarise(count = n()) %>%
  knitr::kable(col.names = c("Transformant", "Nombre de read"), align = "c")

#' ## Nombre de SNP par transformation

snp %>%
  group_by(mutant) %>%
  summarise(count = n()) %>%
  knitr::kable(col.names = c("Transformant", "Nombre de SNP"), align = "c")

#' ## Distribution du nombre de SNP

snp %>%
  group_by(read, mutant) %>%
  summarise(count = n()) %>%
  ggplot(aes(x = count)) +
  geom_density(adjust = 0.4, fill = "gray", alpha = 0.5) +
  labs(x = "Nombre de SNP",
       y = "Densité",
       title = "Distribution du nombre de SNP" )

#' ## Distribution de la qualité des SNP
#'
#' J'ai regardé globalement la distribution de la qualité des SNPs.

,#+ qual1, fig.margin=TRUE
qplot(data = snp, base_q, geom = "density",
      xlab = "Qualité de la base", ylab = "",
      main = "Distribution de la qualité")

#' Si on regarde par globalement comment évolue la qualité des SNPs par séquence :

,#+ qual2, fig.margin=TRUE
snp %>%
  ggplot(aes(x = refp, y = base_q, color = base_q)) +
  geom_line(aes(group = read), alpha = 1/5) +
  geom_point(alpha = 1/10, size = 1/10) +
  scale_color_viridis(begin = 0, end = 0.8) +
  geom_segment(aes(x = max(refp), xend = max(refp) - 20, y = 41.2, yend = 41.2),
               arrow = arrow(length = unit(0.1, "cm")),
               color = "red") +
  annotate("text", x = 668, y = 41.4, label = "1073", size = 2, color = "red") +
  labs(x = "Position", y = "Qualité",
       title = "Évolution de la qualité\nau long de la séquence")

#' Si on regarde cette qualité par séquence :

,#+ qual3, cache=TRUE, fig.width=15, fig.height=7, fig.fullwidth=TRUE
snp %>%
  ggplot(aes(x = refp, y = base_q)) +
  geom_point(alpha = 1/5, size = 0.1) +
  geom_line(alpha = 1) +
  facet_wrap( ~ name) +
  theme(strip.background = element_blank(),
        strip.text = element_text(size= 6),
        axis.text = element_text(size = 5),
        panel.margin = unit(0.1, "lines")) +
  labs(x = "Position", y = "Qualité", title = "Qualité par position\n par séquence")

#' La qualité diminue en fin de séquence. C'est masqué pour l'instant
#' par le fait que j'ai artificiellement appelé N les bases d'une
#' qualité inférieure à $X$ .

#' # Répartition des SNP sur les séquences
#'
#' J'ai voulu regarder globalement la distribution des SNP sur les
#' séquences.

,#+ repar, cache=FALSE, fig.margin=TRUE, fig.cap="La distribution des SNP en fréquence"
snp %>%
  ggplot(aes(x = refp, fill = mutant )) +
  geom_histogram(binwidth = 10) +
  facet_grid(mutant~.) +
  labs(x = "Position", y = "")

,#+ repar2, cache=FALSE, fig.margin=FALSE, fig.cap="La distribution des SNP en densité"
snp %>%
  ggplot(aes(x = refp, fill = mutant )) +
  geom_density(aes(group = mutant), adjust = 1/3, alpha = 1/2) +
  geom_vline(xintercept = snppos_sw, alpha = 0.1) +
  labs(x = "Position",
       y = "Densité",
       title = "Distribution des SNPs sur les reads",
       fill = "Transformant") +
  theme(panel.grid.major.x = element_blank(),
        legend.position = c(0.8, 0.8))

#' ## Définition des transitions

#' J'ai défini une fonction qui permet de déterminer le type de
#' mutation, de strong à weak (`sw`), de weak à strong (`ws`) ou
#' autre.

## #' une fonction qui définit le type de transition, de la référence
## #' à la séquence observée.
find_transition <- function(ref, base) {
  stopifnot(typeof(ref) == "character", typeof(base) == "character")

  is_W <- function(base) ifelse(base == "A" || base == "T", TRUE, FALSE)
  is_S <- function(base) ifelse(base == "C" || base == "G", TRUE, FALSE)

  if      (is_W(ref) & is_S(base)) "ws"
  else if (is_S(ref) & is_W(base)) "sw"
  else if (is_S(ref) & is_S(base)) "ss"
  else if (is_W(ref) & is_W(base)) "ww"
  else stop("Base ", ref, " or base ", base, " is not a DNA base.",
            call. = FALSE)
}

#' J'ai d'abord regardé si on avait des SNPs improbables, *ie* des
#' mutations de W à W (`ww`) ou de S à S (`ss`).

snp %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  filter(trans %in% c("ss", "ww")) %>%
  print()

#' Il n'y en a pas. Plutôt une bonne nouvelle !
#'
#' ## Distribution par type de mutation
#'
#' J'ai voulu voir si les mutations S->W et les mutations W->S étaient
#' réparties différemment sur les séquences.

snp %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  ggplot(aes(x = refp, fill = trans)) +
  geom_density(adjust = 1/3, alpha = 1/2) +
  geom_vline(xintercept = snppos_sw, alpha = 0.1) +
  theme(panel.grid.major.x = element_blank()) +
  labs(x = "Position",
       y = "Densité",
       fill = "Mutation",
       title = "Distribution des mutations") +
  legend_position(0.8, 0.8)

snp %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  ggplot(aes(x = refp )) +
  geom_histogram(aes(fill = trans, color = trans), binwidth = 10,
                 position = "dodge" ) +
  labs(x = "Position", y = "",
       title = "Distribution des mutations",
       fill = "mutation",
       color = "mutation") +
  legend_position(0.75, 0.85)

#' # Trace de conversion
#'
#' ## Distribution de la longueur
#'
#' J'ai ensuite regardé comment étaient réparties les longeurs de
#' trace de conversion sur les séquences.
#'
snp %>%
  group_by(read) %>%
  summarise(max = max(refp)) %>%
  ggplot(aes(x = max)) +
  geom_histogram(binwidth = 10) +
  labs(x = "Longueur de trace de conversion",
       y = "",
       title = "Distribution de la longueur\nde trace de conversion" )

#' ##
#'

snp %>%
  group_by(read, mutant) %>%
  summarise(max = max(refp)) %>%
  inner_join(x = snp, y = .) %>%
  filter(refp == max) %>%
  ggplot(aes(x = refp)) +
  geom_histogram(binwidth = 10)


#' À première vue, le dernier SNP est souvent dans la partie 3' du
#' gène. Cette distribution là n'est pas celle qu'on avait avec les
#' séquences W et S.
#'
#' J'ai donc voulu voir s'il y avait une différence de longueur de
#' trace de conversion entre les séquences de SW et les séquences WS,
#' dans un premier temps en fréquence, puis en densité.

snp %>%
  group_by(read, mutant) %>%
  summarise(max = max(refp)) %>%
  ggplot(aes(x = max)) +
  geom_histogram(aes(fill = mutant), position = "dodge") +
  labs(fill = "Transformant", x = "Longueur de conversion tract", y = "") +
  ggtitle( "Distribution de la\nlongueur de trace de conversion")

snp %>%
  group_by(read, mutant) %>%
  summarise(max = max(refp)) %>%
  ggplot(aes(x = max, fill = mutant, color = mutant)) +
  geom_density(adjust = 1/3, alpha = 0.5) +
  labs(y = "Densité", x = "Position du point de basculement",
       title = "Position du point de basculement") +
  theme(legend.position = c(0.2, 0.81))

#' J'ai voulu voir si le point de switch était plus souvent à un SNP
#' strong que weak.

snp %>%
  group_by(read, mutant) %>%
  summarise(max = max(refp)) %>%
  inner_join(x = snp, y = .) %>%
  filter(refp == max) %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  ggplot(aes(x = max)) +
  geom_histogram(aes(fill = trans, color = trans), position = "dodge", binwidth = 10) +
  legend_position(0.2, 0.5) +
  labs(x = "Position du point de basculement",
       y = "",
       fill = "Mutation",
       color = "Mutation",
       title = "Type de mutation au point de switch")

#' # En(-)quête de néo-mutations…
#'
#' J'ai voulu voir si on retrouvait les néomutations du séquençage
#' précédent dans la trace de conversion. Le problème c'est que cette
#' fois la distribution du nombre de SNP à une position donnée ne
#' permet pas de discriminer facilement les positions de SNP calibré
#' avec les néo-mutations. J'ai donc décidé de ne regarder que les
#' positions où le nombre de SNP est de 1, en supposant qu'elles
#' incluent les positions de néo-mutation.
#'

snp %>%
  group_by(refp) %>%
  summarise(count = n()) %>%
  filter(count == 1) %>%
  print()

#' En clair, il n'y a pas de position où on ne retrouve qu'un
#' SNP. Donc si néo-mutation il y a, elle occasionne dans au moins
#' deux séquences différentes un même SNP. Ce qui est peu probable.

,#+ nombresnp, fig.margin = TRUE
snp %>%
  group_by(refp) %>%
  summarise(count = n()) %>%
  ## filter(count < 5) %>%
  ggplot(aes(x = count)) +
  geom_histogram(binwidth = 1) +
  geom_vline(xintercept = 5, color = "red") +
  annotate("text", label = "x = 5", color = "red", x = 8, y = -0.1) +
  labs(x = "Nombre de SNP",
       y = "",
       title = "Distribution du nombre de SNP par position")

#' En fait aucune position de SNP calibrée ne génère moins de 5
#' mutations. On peut donc en conclure qu'il n'y a pas de néomutations
#' dans cette manip.
#'

#' [ ] échantillonne autant de positions aléatoirement dans les
#' groupes sw et ws. $856$ est le nombre de positions maximum pour
#' équilibrer le plan.
#'
#'
,#+ wip, echo=FALSE

                                        # WIP
snp %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  ungroup() %>%
  group_by(mutant) %>%
  ## (X) filter(base_q > 40 ) %>%
  sample_n(856, FALSE) %>%              # échantillonne autant de positions dans les deux groupes.
  ggplot(aes(x = refp, fill = trans )) +
  geom_histogram(position = "dodge", binwidth = 10) +
  ## geom_density(aes(group = mutant), adjust = 1/5, alpha = 1/2) +
  legend_position(0.8, 0.8)

sapply(1:10, function(i) snp %>% group_by(mutant) %>% sample_n(856) )

                                        # END WIP

test_snp <- apply(
  sapply(1:3, function(i) snp %>% group_by(mutant) %>% sample_n(856)),
  2, as_data_frame
)

test_snp[[1]]
#+END_SRC

* Tests

La fonction /assert/ provient de là :
[[http://tldp.org/LDP/abs/html/debugging.html#ASSERT]]

Le script en question vient de là : https://github.com/lehmannro/assert.sh

#+BEGIN_SRC sh
wget https://raw.github.com/lehmannro/assert.sh/v1.1/assert.sh -O test/assert.sh
chmod +x test/assert.sh
#+END_SRC

Le script pour tester les résultats, via =make test=.

#+BEGIN_SRC sh :tangle test/test.sh
  #!/bin/bash

  # cette fonction renvoit le nombre de séquence dans un fichier fastq poolé.
  # elle divise le nombre de ligne par 4 pour connaître le nombre de séquence.
  check_fastq_length () {
      cat $1 | echo $((`wc -l` / 4))
  }

  set -e

  . ./test/assert.sh

  # vérifie qu'il y ait bien 95 séquence dans le fastq SW et 96 dans le fastq WS
  assert "echo `check_fastq_length data/sw/sw_untrimmed.fastq`" "95"
  assert "echo `check_fastq_length data/ws/ws_untrimmed.fastq`" "96"

  # vérifie qu'yl y ait bien 95 séquences dans le fastq SW trimmé et 96
  # dans le fastq WS trimmé
  assert "echo `check_fastq_length data/sw/sw_untrimmed.fastq.trim`" "90"
  assert "echo `check_fastq_length data/ws/ws_untrimmed.fastq.trim`" "90"
  assert "echo `wc -l data/snp_call/snp_calling.dat | awk '{print $1}'`" "1875"

  assert_end results
#+END_SRC

* Dépendances
** BBmap
Le site de téléchargement est là :
https://sourceforge.net/projects/bbmap

Pour installer bbduk :

#+BEGIN_SRC sh
  wget https://sourceforge.net/projects/bbmap/files/latest/download \
       -o bin/bbmap.tar.gz
  cd bin
  tar xzf bin/bbmap.tar.gz
#+END_SRC

** R markdown
Il faut une version récente du package =rmarkdown=.

#+begin_src R :tangle no
install.package('rmarkdown', type = "source")
#+end_src

* Config                                                           :noexport:

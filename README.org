
#+title: Séquençage WS et SW

Ce dossier contient les séquences des plaques obtenues avec les
constructions SW et WS, envoyées à séquencer le [2016-03-15 Tue].

* Dossiers et fichiers
Les données brutes au format .zip sont dans le dossier =raw=. Elles
sont extraites dans le dossier =data=, séparé en =ws= et =sw= pour les
analyses. Rien ne doit toucher au dossier =raw=.

J'ai ensuite utilisé le script [[./src/sort_into_dir.sh]] pour classer les
fichiers selon leur extension.

#+BEGIN_SRC sh :tangle src/sort_into_dir.sh
#!/bin/bash

cd data/ws

mkdir fasta spectro seq

find . -name "*.fas"  -maxdepth 1 -exec mv {} ./fasta/ \;
find . -name "*.ab1"  -maxdepth 1 -exec mv {} ./spectro/ \;
find . -name "*.seq"  -maxdepth 1 -exec mv {} ./seq/ \;
find . -name "*.csv"  -maxdepth 1 -exec mv {} ../csv/ \;

cd ../sw

mkdir fasta spectro seq

find . -name "*.fas"  -maxdepth 1 -exec mv {} ./fasta/ \;
find . -name "*.ab1"  -maxdepth 1 -exec mv {} ./spectro/ \;
find . -name "*.seq"  -maxdepth 1 -exec mv {} ./seq/ \;
find . -name "*.csv"  -maxdepth 1 -exec mv {} ../csv/ \;
#+END_SRC

* Contrôle qualité
Après avoir reçu les séquences, j'ai voulu connaître la qualité
globale des séquences. Je les ai donc converties en fastq avec le
script [[./src/ab1_to_fastq.sh]], et j'ai utilisé ~fastqc~ pour
représenter la qualité globale via le script [[./src/quality_control.sh]].

#+BEGIN_SRC sh :tangle src/ab1_to_fastq.sh
#!/bin/bash

# transforme en fastq
cd data/ws

touch ws_untrimmed.fastq

for file in spectro/*.ab1
do
    seqret \
        -sformat abi \
        -osformat fastq \
        -auto \
        -stdout \
        -sequence $file \
        >> ws_untrimmed.fastq
done

cd ../sw

# TEMPORAIRE, élimine le fichier .ab1 tendancieux pour l'instant
# rm spectro/psw76-1073bis.ab1

touch sw_untrimmed.fastq

for file in spectro/*.ab1
do
    seqret \
        -sformat abi \
        -osformat fastq \
        -auto \
        -stdout \
        -sequence $file \
        >> sw_untrimmed.fastq
done
#+END_SRC

J'ai utilisé ~fastqc~ pour représenter la qualité globale via le
script [[./src/quality_control.sh]].

#+BEGIN_SRC sh :tangle src/quality_control.sh
#!/bin/bash

# contrôle qualité des séquences.
cd data

# crée un dossier qc de quality control pour ws et sw
mkdir -p qc/{ws,sw}

# fastqc sortie dasn le dossier approprié
fastqc ws/ws_untrimmed.fastq -o qc/ws
fastqc sw/sw_untrimmed.fastq -o qc/sw

# transfert du fichier .png qui nous intéresse dans le dir adapté
# et suppression des dossiers inutiles
#' -qq : very quiet
#' -o  : overwrite without warning
#' -d  : out dir
unzip -qq -o \
      qc/sw/sw_untrimmed_fastqc.zip \
      sw_untrimmed_fastqc/Images/per_base_quality.png \
      -d ../anl/ \
    && mv ../anl/sw_untrimmed_fastqc/Images/per_base_quality.png \
          ../anl/sw_per_base_qual.png \
    && rm -r ../anl/sw_untrimmed_fastqc

# transfert du fichier .png qui nous intéresse dans le dir adapté
# et suppression des dossiers inutiles
unzip -qq -o \
      qc/ws/ws_untrimmed_fastqc.zip \
      ws_untrimmed_fastqc/Images/per_base_quality.png \
      -d ../anl/ \
    && mv ../anl/ws_untrimmed_fastqc/Images/per_base_quality.png \
          ../anl/ws_per_base_qual.png \
    && rm -r ../anl/ws_untrimmed_fastqc
#+END_SRC

À priori les séquences sont plutôt de bonne qualité. Voir le résumé
dans le fichier [[./data/qc/sw/sw_untrimmed_fastqc.html]] et
[[./data/qc/ws/ws_untrimmed_fastqc.html]].

* Analyse rapide du SNP calling de GATC
J'ai rapidement analysé la sortie du SNP calling effectué par GATC,
mais il manque des données. Je vais refaire le SNP calling moi-même,
en utilisant dans un premier temps ssaha2.

#+BEGIN_SRC R :tangle anl/gatc_snpcall/snp_call.r :exports none
  #' ---
  #' title: "Rapide analyse des SNP"
  #' author: "Samuel BARRETO"
  #' date: "31 janvier 2016"
  #' output:
  #'   html_document:
  #'     highlight: tango
  #'     theme: paper
  #'     code_folding: hide
  #'     toc: true
  #'     toc_depth: 2
  #'     toc_float: true
  #' ---

  #' # Lecture des données
  #'
  #' Les données sont les tableurs de snp calling que GATC nous a fait
  #' gratuitement. Ce script n'est que préliminaire, je referai le snp
  #' calling comme il faut par la suite.
  library(dplyr)
  library(ggplot2)
  library(readr)
  library(viridis)

  #' Lecture des données et combinaison dans un seul tableur.
  ws <- read_delim("../../data/csv/1582203.SNP.csv", delim = ";")
  sw <- read_delim("../../data/csv/1582443.SNP.csv", delim = ";")
  ws$type <- "ws"
  sw$type <- "sw"

  #' ## Définition des transitions
  #'
  ## #' une fonction qui définit le type de transition, de la référence
  ## #' à la séquence observée.
  find_transition <- function(ref, base) {
    stopifnot(typeof(ref) == "character", typeof(base) == "character")

    is_W <- function(base) ifelse(base == "A" || base == "T", TRUE, FALSE)
    is_S <- function(base) ifelse(base == "C" || base == "G", TRUE, FALSE)

    if (is_W(ref) & is_S(base)) "ws"
    else if (is_S(ref) & is_W(base)) "sw"
    else if (is_S(ref) & is_S(base)) "ss"
    else if (is_W(ref) & is_W(base)) "ww"
    else stop("Base ", ref, " or base ", base, " is not a DNA base.",
              call. = FALSE)
  }

  data <- rbind(ws, sw) # lie les deux jeux de données
                                          # change les noms de colonne
  colnames(data) <-  c("ref", "pos", "ref.base", "alt.base", "qual",
                       "query", "qpos", "qlen", "type")
                                          # supprime le nom de l'amorce
  data <- mutate(data, query = gsub("-1073bis", "", query))

  ## ggplot default theme
  theme_set(theme_minimal(base_size = 10, base_family = "Courier"))

  #' # Distribution des SNP
  #' Je regarde la distribution des SNP sur les séquences
                                          ,#+distrisnp
  data %>%
    ggplot(aes(x = pos, fill = type)) +
    geom_histogram(binwidth = 10) +
    facet_grid(type~.) +
    xlab("Position sur la reference") +
    ylab("Nombre de SNP")

  #' ## Alignement des séquences
  #'
  #' Je fais rapidement un petit alignement des séquences
  #'
  data %>%
    ggplot(data = ., aes(x = pos, y  = query )) +
    ## geom_text(aes(label = alt.base)) +
    geom_point(aes(color = alt.base), alpha = 0.4)

  data %>%
    group_by(query) %>%
    summarise(end.tc = max(pos)) %>%
    ggplot(aes(x = end.tc)) +
    geom_histogram()

  data %>% select(query) %>% unique()

  #' ## Problème avec les séquences
  #'
  #' Il n'y a que 127 séquences analysées dans ce tableau. Ça ne va pas.
  #' On devrait s'attendre à 192 séquences normalement. Il manque du
  #' signal. Je vais faire l'analyse moi-même.

  data %>%
    select(query) %>%
    unique()
#+END_SRC

Le script est là [[./anl/gatc_snpcall/snp_call.r]], les sorties en
html là [[./anl/gatc_snpcall/snp_call.html]].

* SNP calling global
Dans un premier temps je veux utiliser ssahaSNP pour analyser les
positions de SNP sur l'ensemble des séquences, en trimmant sur la base
de la qualité comme pour les séquences des plaques S et W.

** trimming des séquences

J'ai utilisé le programme bbduk pour trimmer les séquences de faible
qualité.

#+BEGIN_SRC sh :tangle src/qtrim.sh
  #!/bin/bash

  #' -qtrim=rl : quality trim right and left
  #' -trimq=28 : trim if quality < 28 (sanger encoding, illumina 1.9)
  #' -minlen=620 : keep only seq with length > 620, after trimming.
  #' -Xmx1g : tells bbduk / java to use 1G of RAM

  FASTQ="data/sw/sw_untrimmed.fastq
  data/ws/ws_untrimmed.fastq
  "

  for f in $FASTQ
  do
      out=$f.trim
      bin/bbmap/bbduk.sh -Xmx1g \
                         -in=$f \
                         -out=$f.qtrim \
                         -qtrim=rl \
                         -trimq=28 \
                         -minlen=600

      ## convertit les bases d'une qualité inférieure à 20 en N.
      seqtk seq \
            -q20 \
            -nN \
            $f.qtrim > $out

      ## convertit le fastq en fasta
      seqret \
          -sformat fastq \
          -osformat fasta \
          -auto -stdout \
          -sequence $out > $f.fasta

      rm $f.qtrim
  done
#+END_SRC

** Contrôle qualité des séquences trimmées

#+begin_src sh :tangle src/qtrim_qc.sh
  #!/usr/bin/env bash

  cd data

  TRIM="ws/ws_untrimmed.fastq.trim sw/sw_untrimmed.fastq.trim"

  mkdir qtrim_qc

  for f in $TRIM
  do
      fastqc $f -o qtrim_qc
  done
#+end_src

Le script est là [[./src/qtrim_qc.sh]] et les sorties sont là
[[file:data/qtrim_qc/sw_untrimmed.fastq.trim_fastqc.html][data/qtrim_qc/sw_untrimmed.fastq.trim_fastqc.html]] et là
[[file:data/qtrim_qc/sw_untrimmed.fastq.trim_fastqc.html][data/qtrim_qc/ws_untrimmed.fastq.trim_fastqc.html]].
* Tests

La fonction /assert/ provient de là :
[[http://tldp.org/LDP/abs/html/debugging.html#ASSERT]]

Le script en question vient de là : https://github.com/lehmannro/assert.sh

#+BEGIN_SRC sh
wget https://raw.github.com/lehmannro/assert.sh/v1.1/assert.sh -O test/assert.sh
chmod +x test/assert.sh
#+END_SRC

#+begin_src sh :tangle test/test.sh
  #!/bin/bash

  # cette fonction renvoit le nombre de séquence dans un fichier fastq poolé.
  # elle divise le nombre de ligne par 4 pour connaître le nombre de séquence.
  check_fastq_length () {
      cat $1 | echo $((`wc -l` / 4))
  }

  set -e

  . ./test/assert.sh

  # vérifie qu'il y ait bien 95 séquence dans le fastq SW et 96 dans le fastq WS
  assert "echo `check_fastq_length data/sw/sw_untrimmed.fastq`" "95"
  assert "echo `check_fastq_length data/ws/ws_untrimmed.fastq`" "96"

  # vérifie qu'yl y ait bien 95 séquences dans le fastq SW trimmé et 96
  # dans le fastq WS trimmé
  assert "echo `check_fastq_length data/sw/sw_untrimmed.fastq.trim`" "90"
  assert "echo `check_fastq_length data/ws/ws_untrimmed.fastq.trim`" "90"

  assert_end demo
#+end_src


* Dépendances
** BBmap
Le site de téléchargement est là :
https://sourceforge.net/projects/bbmap

Pour installer bbduk :

#+BEGIN_SRC sh
  wget https://sourceforge.net/projects/bbmap/files/latest/download \
       -o bin/bbmap.tar.gz
  cd bin
  tar xzf bin/bbmap.tar.gz
#+END_SRC

** R markdown
Il faut une version récente du package =rmarkdown=.

#+begin_src R :tangle no
install.package('rmarkdown', type = "source")
#+end_src

* Config                                                           :noexport:

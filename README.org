#+title: Séquençage WS et SW

Ce dossier contient les séquences des plaques obtenues avec les
constructions SW et WS, envoyées à séquencer le [2016-03-15 Tue].

* Dossiers et fichiers
Les données brutes au format .zip sont dans le dossier =raw=. Elles
sont extraites dans le dossier =data=, séparé en =ws= et =sw= pour les
analyses. Rien ne doit toucher au dossier =raw=.

J'ai ensuite utilisé le script [[./src/sort_into_dir.sh]] pour classer les
fichiers selon leur extension.

#+BEGIN_SRC sh :tangle src/sort_into_dir.sh
#!/bin/bash

cd data/ws

mkdir fasta spectro seq

find . -name "*.fas"  -maxdepth 1 -exec mv {} ./fasta/ \;
find . -name "*.ab1"  -maxdepth 1 -exec mv {} ./spectro/ \;
find . -name "*.seq"  -maxdepth 1 -exec mv {} ./seq/ \;
find . -name "*.csv"  -maxdepth 1 -exec mv {} ../csv/ \;

cd ../sw

mkdir fasta spectro seq

find . -name "*.fas"  -maxdepth 1 -exec mv {} ./fasta/ \;
find . -name "*.ab1"  -maxdepth 1 -exec mv {} ./spectro/ \;
find . -name "*.seq"  -maxdepth 1 -exec mv {} ./seq/ \;
find . -name "*.csv"  -maxdepth 1 -exec mv {} ../csv/ \;
#+END_SRC

* Contrôle qualité
Après avoir reçu les séquences, j'ai voulu connaître la qualité
globale des séquences. Je les ai donc converties en fastq avec le
script [[./src/ab1_to_fastq.sh]], et j'ai utilisé ~fastqc~ pour
représenter la qualité globale via le script [[./src/quality_control.sh]].

#+BEGIN_SRC sh :tangle src/ab1_to_fastq.sh
#!/bin/bash

# transforme en fastq
cd data/ws

touch ws_untrimmed.fastq

for file in spectro/*.ab1
do
    seqret \
        -sformat abi \
        -osformat fastq \
        -auto \
        -stdout \
        -sequence $file \
        >> ws_untrimmed.fastq
done

cd ../sw

# TEMPORAIRE, élimine le fichier .ab1 tendancieux pour l'instant
# rm spectro/psw76-1073bis.ab1

touch sw_untrimmed.fastq

for file in spectro/*.ab1
do
    seqret \
        -sformat abi \
        -osformat fastq \
        -auto \
        -stdout \
        -sequence $file \
        >> sw_untrimmed.fastq
done
#+END_SRC

J'ai utilisé ~fastqc~ pour représenter la qualité globale via le
script [[./src/quality_control.sh]].

#+BEGIN_SRC sh :tangle src/quality_control.sh
#!/bin/bash

# contrôle qualité des séquences.
cd data

# crée un dossier qc de quality control pour ws et sw
mkdir -p qc/{ws,sw}

# fastqc sortie dasn le dossier approprié
fastqc ws/ws_untrimmed.fastq -o qc/ws
fastqc sw/sw_untrimmed.fastq -o qc/sw

# transfert du fichier .png qui nous intéresse dans le dir adapté
# et suppression des dossiers inutiles
#' -qq : very quiet
#' -o  : overwrite without warning
#' -d  : out dir
unzip -qq -o \
      qc/sw/sw_untrimmed_fastqc.zip \
      sw_untrimmed_fastqc/Images/per_base_quality.png \
      -d ../anl/ \
    && mv ../anl/sw_untrimmed_fastqc/Images/per_base_quality.png \
          ../anl/sw_per_base_qual.png \
    && rm -r ../anl/sw_untrimmed_fastqc

# transfert du fichier .png qui nous intéresse dans le dir adapté
# et suppression des dossiers inutiles
unzip -qq -o \
      qc/ws/ws_untrimmed_fastqc.zip \
      ws_untrimmed_fastqc/Images/per_base_quality.png \
      -d ../anl/ \
    && mv ../anl/ws_untrimmed_fastqc/Images/per_base_quality.png \
          ../anl/ws_per_base_qual.png \
    && rm -r ../anl/ws_untrimmed_fastqc
#+END_SRC

À priori les séquences sont plutôt de bonne qualité. Voir le résumé
dans le fichier [[./data/qc/sw/sw_untrimmed_fastqc.html]] et
[[./data/qc/ws/ws_untrimmed_fastqc.html]].

* Analyse rapide du SNP calling de GATC
J'ai rapidement analysé la sortie du SNP calling effectué par GATC,
mais il manque des données. Je vais refaire le SNP calling moi-même,
en utilisant dans un premier temps ssaha2.

#+BEGIN_SRC R :tangle anl/gatc_snpcall/snp_call.r :exports none
  #' ---
  #' title: "Rapide analyse des SNP"
  #' author: "Samuel BARRETO"
  #' date: "31 janvier 2016"
  #' output:
  #'   html_document:
  #'     highlight: tango
  #'     theme: paper
  #'     code_folding: hide
  #'     toc: true
  #'     toc_depth: 2
  #'     toc_float: true
  #' ---

  #' # Lecture des données
  #'
  #' Les données sont les tableurs de snp calling que GATC nous a fait
  #' gratuitement. Ce script n'est que préliminaire, je referai le snp
  #' calling comme il faut par la suite.
  library(dplyr)
  library(ggplot2)
  library(readr)
  library(viridis)

  #' Lecture des données et combinaison dans un seul tableur.
  ws <- read_delim("../../data/csv/1582203.SNP.csv", delim = ";")
  sw <- read_delim("../../data/csv/1582443.SNP.csv", delim = ";")
  ws$type <- "ws"
  sw$type <- "sw"

  #' ## Définition des transitions
  #'
  ## #' une fonction qui définit le type de transition, de la référence
  ## #' à la séquence observée.
  find_transition <- function(ref, base) {
    stopifnot(typeof(ref) == "character", typeof(base) == "character")

    is_W <- function(base) ifelse(base == "A" || base == "T", TRUE, FALSE)
    is_S <- function(base) ifelse(base == "C" || base == "G", TRUE, FALSE)

    if (is_W(ref) & is_S(base)) "ws"
    else if (is_S(ref) & is_W(base)) "sw"
    else if (is_S(ref) & is_S(base)) "ss"
    else if (is_W(ref) & is_W(base)) "ww"
    else stop("Base ", ref, " or base ", base, " is not a DNA base.",
              call. = FALSE)
  }

  data <- rbind(ws, sw) # lie les deux jeux de données
                                          # change les noms de colonne
  colnames(data) <-  c("ref", "pos", "ref.base", "alt.base", "qual",
                       "query", "qpos", "qlen", "type")
                                          # supprime le nom de l'amorce
  data <- mutate(data, query = gsub("-1073bis", "", query))

  ## ggplot default theme
  theme_set(theme_minimal(base_size = 10, base_family = "Courier"))

  #' # Distribution des SNP
  #' Je regarde la distribution des SNP sur les séquences
                                          ,#+distrisnp
  data %>%
    ggplot(aes(x = pos, fill = type)) +
    geom_histogram(binwidth = 10) +
    facet_grid(type~.) +
    xlab("Position sur la reference") +
    ylab("Nombre de SNP")

  #' ## Alignement des séquences
  #'
  #' Je fais rapidement un petit alignement des séquences
  #'
  data %>%
    ggplot(data = ., aes(x = pos, y  = query )) +
    ## geom_text(aes(label = alt.base)) +
    geom_point(aes(color = alt.base), alpha = 0.4)

  data %>%
    group_by(query) %>%
    summarise(end.tc = max(pos)) %>%
    ggplot(aes(x = end.tc)) +
    geom_histogram()

  data %>% select(query) %>% unique()

  #' ## Problème avec les séquences
  #'
  #' Il n'y a que 127 séquences analysées dans ce tableau. Ça ne va pas.
  #' On devrait s'attendre à 192 séquences normalement. Il manque du
  #' signal. Je vais faire l'analyse moi-même.

  data %>%
    select(query) %>%
    unique()
#+END_SRC

Le script est là [[./anl/gatc_snpcall/snp_call.r]], les sorties en
html là [[./anl/gatc_snpcall/snp_call.html]].

* SNP calling global
** trimming des séquences

J'ai utilisé le programme bbduk pour trimmer les séquences de faible
qualité.

#+BEGIN_SRC sh :tangle src/qtrim.sh
  #!/bin/bash

  #' -qtrim=rl : quality trim right and left
  #' -trimq=28 : trim if quality < 28 (sanger encoding, illumina 1.9)
  #' -minlen=620 : keep only seq with length > 620, after trimming.
  #' -Xmx1g : tells bbduk / java to use 1G of RAM

  FASTQ="data/sw/sw_untrimmed.fastq
  data/ws/ws_untrimmed.fastq
  "

  for f in $FASTQ
  do
      out=$f.trim
      bin/bbmap/bbduk.sh -Xmx1g \
                         -in=$f \
                         -out=$f.qtrim \
                         -qtrim=rl \
                         -trimq=28 \
                         -minlen=600

      ## convertit les bases d'une qualité inférieure à 20 en N.
      seqtk seq \
            -q20 \
            -nN \
            $f.qtrim > $out

      ## convertit le fastq en fasta
      seqret \
          -sformat fastq \
          -osformat fasta \
          -auto -stdout \
          -sequence $out > $f.fasta

      rm $f.qtrim
  done
#+END_SRC

** Contrôle qualité des séquences trimmées

#+begin_src sh :tangle src/qtrim_qc.sh
  #!/usr/bin/env bash

  cd data

  TRIM="ws/ws_untrimmed.fastq.trim sw/sw_untrimmed.fastq.trim"

  mkdir qtrim_qc

  for f in $TRIM
  do
      fastqc $f -o qtrim_qc
  done
#+end_src

Le script est là [[./src/qtrim_qc.sh]] et les sorties sont là
[[file:data/qtrim_qc/sw_untrimmed.fastq.trim_fastqc.html][./data/qtrim_qc/sw_untrimmed.fastq.trim_fastqc.html]] et là
[[file:data/qtrim_qc/sw_untrimmed.fastq.trim_fastqc.html][./data/qtrim_qc/ws_untrimmed.fastq.trim_fastqc.html]].

Les séquences sont nettement raccourcies par rapport aux séquences non trimmées. Mais l'ensemble des
bases qu'on veut analyser sont de bonne qualité. C'est donc plutôt bon signe.

** Pooling des séquences dans un seul fastq

#+BEGIN_SRC sh :tangle src/pool_trim.sh
  #!/usr/bin/env bash

  cat data/sw/sw_untrimmed.fastq.trim data/ws/ws_untrimmed.fastq.trim > data/trimmed.fastq
#+END_SRC

[[./src/pool_trim.sh]]

** Analyses des alignements via seaview
Pour les analyses dans seaview, il faut un fichier fasta. Je lui
ajoute la référence.

#+BEGIN_SRC sh :tangle src/trim_to_fasta.sh
#!/usr/bin/env bash

seqret -sformat fastq -osformat fasta -auto -stdout \
       -sequence data/trimmed.fastq > data/trimmed.fasta

fastx_reverse_complement \
    -i raw/ref/reference1073bis-1392.fasta \
    >> data/trimmed.fasta

#+END_SRC

[[./src/trim_to_fasta.sh]]

J'ai placé les différentes analyses graphiques via seaview dans le
dossier [[./anl/align]].

Différents alignements :
- l'alignement global : [[./anl/align/trimmed.mase][./anl/align/trimmed.mase]]
- l'alignement avec seulement les sites variables : [[./anl/align/variable_site.mase]]

Sur l'alignement global, j'ai repéré quelques cas de traces complexes,
où des séquences avaient ‘gardé’ leur allèle sauvage, quand les deux
SNP environnants sont les SNP transformants.

** snp calling via ssahaSNP

Pour installer ssahaSNP voir les instructions là :
ftp://ftp.sanger.ac.uk/pub/resources/software/ssahasnp/.

Il est très important que les fichiers fasta de référence soit formattés de la
bonne façon, sinon ssahaSNP ne sort pas les bonnes valeurs dans les lignes de
tableau.

#+begin_src sh :tangle src/snp_call.sh
   #!/usr/bin/env bash

   # Variant calling using ssaha2 and ssahaSNP

   if [ ! -e data/snp_call ]
   then
       mkdir data/snp_call
   fi

   cd data/snp_call

   if [[ ! -e trimmed.fastq && ! -e ref.fasta ]]
   then
       ln -s    ../trimmed.fastq .
       ln -s ../../raw/ref/reference1073bis-1392.fasta ref.fasta
   fi

   ## alignement à la séquence de référence
   #' -output psl :             format de sortie psl
   #' reference_reverse.fasta : séquence de référence
   #' trimmed.fastq :           séquence à aligner
   #' output.psl :              fichier de sortie
   ../../bin/ssahaSNP/ssaha2 -output psl ref.fasta trimmed.fastq > output.psl

   ## column annotation based on
   ## ftp://ftp.sanger.ac.uk/pub/resources/software/ssahasnp/readme,
   ## part (6) some further information
   # la première ligne du fichier .dat, afin d'être lu dans R
   cat \
       <( echo "match subject_name index_of_subject read_name s_base q_base s_qual q_qual offset_on_subject offset_on_read length_of_snp start_match_of_read end_match_of_read match_direction length_of_subject" ) \
       <( ../../bin/ssahaSNP/ssahaSNP ref.fasta trimmed.fastq | \
                egrep ssaha:SNP | \
                awk '{print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15}') \
       > snp_calling.dat
#+end_src

Le script est là : [[./src/snp_call.sh]].

** création de la table d'identification des clones
Les spectrogrammes contiennent l'info permettant de relier à un
identifiant de séquence le nom expérimental qu'on lui a attribué.

#+BEGIN_SRC python :tangle src/make_id_table.py
  #!/usr/bin/env python

  from Bio import SeqIO
  from glob import glob
  from os.path import basename

  def sw_or_ws(mutant_name):
      """
      Determine si le mutant est SW ou WS
      """
      if 'sw' in mutant_name:
          return 'sw'
      else:
          return 'ws'

  # en tete de colonne
  print "id name mutant"

  def print_seq_id(dna_seq):
      with open(dna_seq, "rb") as spectro:
          sequence = list(SeqIO.parse(spectro, "abi"))
          print sequence[0].id + " " + sequence[0].name + " " + sw_or_ws(sequence[0].name)

  for file in glob("data/sw/spectro/*.ab1"):
      if basename(file) != "psw76-1073bis.ab1": # exclut la sequence qui pose probleme
          print_seq_id(file)

  for file in glob("data/ws/spectro/*.ab1"):
      print_seq_id(file)
#+END_SRC

** Analyses des résultats de snp calling
#+BEGIN_SRC R :tangle anl/snp_call/snp_call.r :exports none
#' ---
#' title: Analyse globale des SNP
#' author: Samuel BARRETO
#' date:
#' output:
#'   tufte::tufte_html:
#'     highlight: tango
#'     toc: true
#'     toc_depth: 2
#' ---


#' # Lecture des données et nettoyage
#'
#' Il faut dans un premier temps lire les données, les nettoyer et associer à
#' chaque séquence la catégorie de plasmide transformeur.
#'
#' La table des identifiants est faite par le script python.
#'

,#+ setup, include=FALSE
library(knitr)
library(tufte)
opts_chunk$set(cache = FALSE, dev = 'png', include = TRUE,
               echo = TRUE, warning = FALSE, error = FALSE,
               message = FALSE)

fte_theme <- function() {
  ## Generate the colors for the chart procedurally with RColorBrewer
  palette <- RColorBrewer::brewer.pal("Greys", n=9)
  color.background = palette[2]
  color.grid.major = palette[3]
  color.axis.text = palette[6]
  color.axis.title = palette[7]
  color.title = palette[9]

  ## Begin construction of chart
  theme_bw(base_size=9) +
    ## Set the entire chart region to a light gray color
    theme(panel.background=element_rect(fill=color.background, color=color.background),
          plot.background=element_rect(fill=color.background, color=color.background),
          panel.border=element_rect(color=color.background),
          panel.grid.major=element_line(color=color.grid.major,size=.25),
          panel.grid.minor=element_blank(),
          axis.ticks=element_blank(),
          ## Format the legend, but hide by default
          legend.position="none",
          legend.background = element_rect(fill = scales::alpha(color.background, 0.3)),
          legend.text = element_text(size=7,color=color.axis.title),
          ## Set title and axis labels, and format these and tick marks
          plot.title=element_text(color=color.title, size=14,
                                  face = "bold", vjust=1.25, hjust = 0),
          axis.text.x=element_text(size=7,color=color.axis.text),
          axis.text.y=element_text(size=7,color=color.axis.text),
          axis.title.x=element_text(size=8, color=color.axis.title, vjust=0, hjust = 0.8),
          axis.title.y=element_text(size=8, color=color.axis.title, vjust = 0.9, angle = 0 ),
          ## Plot margins
          plot.margin = unit(c(0.35, 0.2, 0.3, 0.35), "cm"))
}

legend_position <- function(x, y) theme(legend.position = c(x, y))

,#+ setup2, include = TRUE
library(dplyr)
library(ggplot2)
library(readr)
library(viridis)
library(purrr)
library(ggthemes)

theme_set(theme_bw() + fte_theme())

data_location <- "../../data/snp_call/snp_calling.dat"
id_table_loc <- "../../data/id_table.dat"

#' J'ai relié les données par un `inner_join` sur la base du nom de
#' l'identifiant de la séquence GATC.

snp <- inner_join(
  x = read_delim(file = data_location, delim = " "),
  y = read_delim(file = id_table_loc, delim = " "),
  by=c("read_name" = "id")) %>%
  select(
    -match,
    -subject_name,
    -index_of_subject,
    read = read_name,
    refb = s_base,
    readb = q_base,
    -s_qual,
    base_q = q_qual,
    refp = offset_on_subject,
    readp = offset_on_read,
    -length_of_subject,
    -length_of_snp,
    readfp = start_match_of_read,
    readlp = end_match_of_read,
    dir = match_direction) %>%
  mutate(name = gsub("-1073bis", "", name))

#' J'ai déterminé les positions des SNP qui nous intéressent dans les
#' deux variables suivantes ^[Le code suivant aurait pu inclure les
#' néomutations. Mais à priori, il n'y en a pas.].

snppos_sw <- filter(snp, mutant == "sw") %>%
  select(refp) %>%
  distinct() %>%
  unlist() %>%
  as.vector()
snppos_ws <- filter(snp, mutant == "ws") %>%
  select(refp) %>%
  distinct() %>%
  unlist() %>%
  as.vector()


#' # Observations générales
#'
#' ## Nombres de reads par transformation

snp %>%
  group_by(read, mutant) %>%
  summarise(count = n()) %>%
  group_by(mutant) %>%
  summarise(count = n()) %>%
  knitr::kable(col.names = c("Transformant", "Nombre de read"), align = "c")

#' ## Nombre de SNP par transformation

snp %>%
  group_by(mutant) %>%
  summarise(count = n()) %>%
  knitr::kable(col.names = c("Transformant", "Nombre de SNP"), align = "c")

#' ## Distribution du nombre de SNP

snp %>%
  group_by(read, mutant) %>%
  summarise(count = n()) %>%
  ggplot(aes(x = count)) +
  geom_density(adjust = 0.4, fill = "gray", alpha = 0.5) +
  labs(x = "Nombre de SNP",
       y = "Densité",
       title = "Distribution du nombre de SNP" )

#' ## Distribution de la qualité des SNP
#'
#' J'ai regardé globalement la distribution de la qualité des SNPs.

,#+ qual1, fig.margin=TRUE
qplot(data = snp, base_q, geom = "density",
      xlab = "Qualité de la base", ylab = "",
      main = "Distribution de la qualité")

#' Si on regarde par globalement comment évolue la qualité des SNPs par séquence :

,#+ qual2, fig.margin=TRUE
snp %>%
  ggplot(aes(x = refp, y = base_q, color = base_q)) +
  geom_line(aes(group = read), alpha = 1/5) +
  geom_point(alpha = 1/10, size = 1/10) +
  scale_color_viridis(begin = 0, end = 0.8) +
  geom_segment(aes(x = max(refp), xend = max(refp) - 20, y = 41.2, yend = 41.2),
               arrow = arrow(length = unit(0.1, "cm")),
               color = "red") +
  annotate("text", x = 668, y = 41.4, label = "1073", size = 2, color = "red") +
  labs(x = "Position", y = "Qualité",
       title = "Évolution de la qualité\nau long de la séquence")

#' Si on regarde cette qualité par séquence :

,#+ qual3, cache=TRUE, fig.width=15, fig.height=7, fig.fullwidth=TRUE
snp %>%
  ggplot(aes(x = refp, y = base_q)) +
  geom_point(alpha = 1/5, size = 0.1) +
  geom_line(alpha = 1) +
  facet_wrap( ~ name) +
  theme(strip.background = element_blank(),
        strip.text = element_text(size= 6),
        axis.text = element_text(size = 5),
        panel.margin = unit(0.1, "lines")) +
  labs(x = "Position", y = "Qualité", title = "Qualité par position\n par séquence")

#' La qualité diminue en fin de séquence. C'est masqué pour l'instant
#' par le fait que j'ai artificiellement appelé N les bases d'une
#' qualité inférieure à $X$ .

#' # Répartition des SNP sur les séquences
#'
#' J'ai voulu regarder globalement la distribution des SNP sur les
#' séquences.

,#+ repar, cache=FALSE, fig.margin=TRUE, fig.cap="La distribution des SNP en fréquence"
snp %>%
  ggplot(aes(x = refp, fill = mutant )) +
  geom_histogram(binwidth = 10) +
  facet_grid(mutant~.) +
  labs(x = "Position", y = "")

,#+ repar2, cache=FALSE, fig.margin=FALSE, fig.cap="La distribution des SNP en densité"
snp %>%
  ggplot(aes(x = refp, fill = mutant )) +
  geom_density(aes(group = mutant), adjust = 1/3, alpha = 1/2) +
  geom_vline(xintercept = snppos_sw, alpha = 0.1) +
  labs(x = "Position",
       y = "Densité",
       title = "Distribution des SNPs sur les reads",
       fill = "Transformant") +
  theme(panel.grid.major.x = element_blank(),
        legend.position = c(0.8, 0.8))

#' ## Définition des transitions

#' J'ai défini une fonction qui permet de déterminer le type de
#' mutation, de strong à weak (`sw`), de weak à strong (`ws`) ou
#' autre.

## #' une fonction qui définit le type de transition, de la référence
## #' à la séquence observée.
find_transition <- function(ref, base) {
  stopifnot(typeof(ref) == "character", typeof(base) == "character")

  is_W <- function(base) ifelse(base == "A" || base == "T", TRUE, FALSE)
  is_S <- function(base) ifelse(base == "C" || base == "G", TRUE, FALSE)

  if      (is_W(ref) & is_S(base)) "ws"
  else if (is_S(ref) & is_W(base)) "sw"
  else if (is_S(ref) & is_S(base)) "ss"
  else if (is_W(ref) & is_W(base)) "ww"
  else stop("Base ", ref, " or base ", base, " is not a DNA base.",
            call. = FALSE)
}

#' J'ai d'abord regardé si on avait des SNPs improbables, *ie* des
#' mutations de W à W (`ww`) ou de S à S (`ss`).

snp %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  filter(trans %in% c("ss", "ww")) %>%
  print()

#' Il n'y en a pas. Plutôt une bonne nouvelle !
#'
#' ## Distribution par type de mutation
#'
#' J'ai voulu voir si les mutations S->W et les mutations W->S étaient
#' réparties différemment sur les séquences.

snp %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  ggplot(aes(x = refp, fill = trans)) +
  geom_density(adjust = 1/3, alpha = 1/2) +
  geom_vline(xintercept = snppos_sw, alpha = 0.1) +
  theme(panel.grid.major.x = element_blank()) +
  labs(x = "Position",
       y = "Densité",
       fill = "Mutation",
       title = "Distribution des mutations") +
  legend_position(0.8, 0.8)

snp %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  ggplot(aes(x = refp )) +
  geom_histogram(aes(fill = trans, color = trans), binwidth = 10,
                 position = "dodge" ) +
  labs(x = "Position", y = "",
       title = "Distribution des mutations",
       fill = "mutation",
       color = "mutation") +
  legend_position(0.75, 0.85)

#' # Trace de conversion
#'
#' ## Distribution de la longueur
#'
#' J'ai ensuite regardé comment étaient réparties les longeurs de
#' trace de conversion sur les séquences.
#'
snp %>%
  group_by(read) %>%
  summarise(max = max(refp)) %>%
  ggplot(aes(x = max)) +
  geom_histogram(binwidth = 10) +
  labs(x = "Longueur de trace de conversion",
       y = "",
       title = "Distribution de la longueur\nde trace de conversion" )

#' ##
#'

snp %>%
  group_by(read, mutant) %>%
  summarise(max = max(refp)) %>%
  inner_join(x = snp, y = .) %>%
  filter(refp == max) %>%
  ggplot(aes(x = refp)) +
  geom_histogram(binwidth = 10)


#' À première vue, le dernier SNP est souvent dans la partie 3' du
#' gène. Cette distribution là n'est pas celle qu'on avait avec les
#' séquences W et S.
#'
#' J'ai donc voulu voir s'il y avait une différence de longueur de
#' trace de conversion entre les séquences de SW et les séquences WS,
#' dans un premier temps en fréquence, puis en densité.

snp %>%
  group_by(read, mutant) %>%
  summarise(max = max(refp)) %>%
  ggplot(aes(x = max)) +
  geom_histogram(aes(fill = mutant), position = "dodge") +
  labs(fill = "Transformant", x = "Longueur de conversion tract", y = "") +
  ggtitle( "Distribution de la\nlongueur de trace de conversion")

snp %>%
  group_by(read, mutant) %>%
  summarise(max = max(refp)) %>%
  ggplot(aes(x = max, fill = mutant, color = mutant)) +
  geom_density(adjust = 1/3, alpha = 0.5) +
  labs(y = "Densité", x = "Position du point de basculement",
       title = "Position du point de basculement") +
  theme(legend.position = c(0.2, 0.81))

#' J'ai voulu voir si le point de switch était plus souvent à un SNP
#' strong que weak.

snp %>%
  group_by(read, mutant) %>%
  summarise(max = max(refp)) %>%
  inner_join(x = snp, y = .) %>%
  filter(refp == max) %>%
  rowwise() %>%
  mutate(trans = find_transition(refb, readb)) %>%
  ggplot(aes(x = max)) +
  geom_histogram(aes(fill = trans, color = trans), position = "dodge", binwidth = 10) +
  legend_position(0.2, 0.3) +
  labs(x = "Position du point de basculement",
       y = "",
       fill = "Mutation",
       color = "Mutation",
       title = "Type de mutation au point de switch") +
  facet_grid( mutant ~ .)

#' # En(-)quête de néo-mutations…
#'
#' J'ai voulu voir si on retrouvait les néomutations du séquençage
#' précédent dans la trace de conversion. Le problème c'est que cette
#' fois la distribution du nombre de SNP à une position donnée ne
#' permet pas de discriminer facilement les positions de SNP calibré
#' avec les néo-mutations. J'ai donc décidé de ne regarder que les
#' positions où le nombre de SNP est de 1, en supposant qu'elles
#' incluent les positions de néo-mutation.
#'

snp %>%
  group_by(refp) %>%
  summarise(count = n()) %>%
  filter(count == 1) %>%
  print()

#' En clair, il n'y a pas de position où on ne retrouve qu'un
#' SNP. Donc si néo-mutation il y a, elle occasionne dans au moins
#' deux séquences différentes un même SNP. Ce qui est peu probable.

,#+ nombresnp, fig.margin = TRUE
snp %>%
  group_by(refp) %>%
  summarise(count = n()) %>%
  ## (X) filter(count < 5) %>%
  ggplot(aes(x = count)) +
  geom_histogram(binwidth = 1) +
  geom_vline(xintercept = 5, color = "red") +
  annotate("text", label = "x = 5", color = "red", x = 8, y = -0.1) +
  labs(x = "Nombre de SNP",
       y = "",
       title = "Distribution du nombre de SNP par position")

#' En fait aucune position de SNP calibrée ne génère moins de 5
#' mutations. On peut donc en conclure qu'il n'y a pas de néomutations
#' dans cette manip.

## (X) #' [ ] échantillonne autant de positions aléatoirement dans les
## (X) #' groupes sw et ws. $856$ est le nombre de positions maximum pour
## (X) #' équilibrer le plan.
## (X) #'
## (X) #'
## (X) #+ wip, echo=FALSE

## (X)                                         # WIP
## (X) snp %>%
## (X)   rowwise() %>%
## (X)   mutate(trans = find_transition(refb, readb)) %>%
## (X)   ungroup() %>%
## (X)   group_by(mutant) %>%
## (X)   ## (X) filter(base_q > 40 ) %>%
## (X)   sample_n(856, FALSE) %>%              # échantillonne autant de positions dans les deux groupes.
## (X)   ggplot(aes(x = refp, fill = trans )) +
## (X)   geom_histogram(position = "dodge", binwidth = 10) +
## (X)   ## geom_density(aes(group = mutant), adjust = 1/5, alpha = 1/2) +
## (X)   legend_position(0.8, 0.8)

## (X) sapply(1:10, function(i) snp %>% group_by(mutant) %>% sample_n(856) )

## (X)                                         # END WIP

## (X) ## (X) test_snp <- apply(
## (X) ## (X)   sapply(1:3, function(i) snp %>% group_by(mutant) %>% sample_n(856)),
## (X) ## (X)   2, as_data_frame
## (X) ## (X) )

## (X) ## (X) test_snp[[1]]

## (X) snp %>%
## (X)   group_by(read, mutant) %>%
## (X)   summarise(max = max(refp)) %>%
## (X)   inner_join(x = snp, y = .) %>%
## (X)   filter(refp == max) %>%
## (X)   rowwise() %>%
## (X)   mutate(trans = find_transition(refb, readb)) %>%
## (X)   ggplot(aes(x = max)) +
## (X)   geom_histogram(aes(fill = trans, color = trans), position = "dodge", binwidth = 10) +
## (X)   ## legend_position(0.2, 0.5) +
## (X)   labs(x = "Position du point de basculement",
## (X)        y = "",
## (X)        fill = "Mutation",
## (X)        color = "Mutation",
## (X)        title = "Type de mutation au point de switch") +
## (X)   facet_grid( mutant )
#+END_SRC

* SNP calling précis [0%]

** phred + muscle = phruscle !
Le SNP calling via ssahaSNP ne permet pas de connaître l'ensemble des
informations dont on a besoin. Un peu dans l'esprit de polySNP, je
veux écrire un script python qui permette :

1. de lancer phred sur la séquence abi en entrée.
2. de lancer muscle avec pour entrée le fichier d'alignement fst entre
   le gène synthétique et la séquence sauvage d'une part, et la
   séquence dans le fichier seq d'autre part.
3. d'analyser la sortie de phred .phd pour extraire l'information de
   la qualité de la base.

Étant donné le nombre de séquence faible, j'ai fait le choix de lancer
muscle à chaque séquence. Une façon plus efficace de faire la même
chose serait d'aligner l'ensemble des séquences SNP WS d'un coup, avec
leur référence, mais c'est un peu plus compliqué à programmer.

#+BEGIN_SRC python :tangle src/phruscle.py
# -*- coding: utf-8 -*-

# 1. lancer phred sur la séquence abi en entrée.
# 2. lancer muscle avec pour entrée le fichier d'alignement fst entre
#    le gène synthétique et la séquence sauvage d'une part, et la
#    séquence dans le fichier seq d'autre part.
# 3. analyser la sortie de phred .phd pour extraire l'information de
#    la qualité de la base.

import os.path
import io
import subprocess as sub  # permet de lancer phred et muscle
import click  # construit la cli
from Bio import AlignIO  # permet d'analyser les sorties de muscle.
from Bio import SeqIO  # permet de tester les entrées
from Bio.Seq import Seq
import numpy as np
import pandas as pd

# TODO: définir les chemins de fichiers avec constance.


@click.group()
def phruscle():
    """This program gather a set of function to run phred on a abi file, to run muscle on the
    called bases, and to give a nicely formatted output as csv.

    """
    pass


def is_abi(sequence):
    """Check if sequence if a spectrogram from abi file.

    :param sequence: sequence file name. str.

    """
    if os.path.splitext(sequence)[1].lower().endswith(('abi', 'ab1')):
        return True
    else:
        return False


def is_fasta(sequence):
    """Check if sequence is a fasta file.

    :param sequence: name of the fasta file. str

    """
    ext = os.path.splitext(sequence)[1].lower()
    if ext.endswith(('.seq', '.fasta', '.aln', '.fst', '.rev')):
        return True
    else:
        return False

##-----------------------------------------------------------------------------
##                                          BASECALL
##-----------------------------------------------------------------------------


@phruscle.command('basecall', short_help='Make basecall and alignment.')
@click.option('-i',
              '--input',
              type=click.File('rb'),
              default='-',
              help="The abi sequence to base call with phred")
@click.option('-r',
              '--ref',
              type=click.File('r'),
              default='-',
              help="The reference alignment in fasta format")
@click.option('-c',
              '--cutoff',
              default=0.05,
              help="Probability of error of basecalling")
@click.option('--reverse',
              is_flag=True,
              help="Reverse complement sequencing file.")
@click.option('--clustalw',
              is_flag=True,
              help="Muscle output in human readable clustalw format")
def run_phruscle(input, ref, cutoff, reverse, clustalw):
    """This programme uses phred to call bases on the `--input` file to create a fasta file.
    Muscle align this fasta file to the `--ref`, without disrupting the reference,
    to get the localisation of SNPs and their polarity.

    :param input: the abi file to run phred on. str
    :param ref: the reference alignment. str
    :param cutoff: the maximum phred probability of error.
    :param reverse: bool. compute reverse complement of input.
    :param clustalw: bool. muscle output as human readable format clustalw.
    """

    def run_phred(abi_file, cutoff):
        """Run phred on the abi_file, with a probability of base calling error of cutoff.

        :param abi_file: the sanger sequencing file to base call. str
        :param cutoff: probability of error. float.
        """
        # print abi_file.name
        assert is_abi(abi_file.name), "Abi_File is not, well…, an abi file."

        # phred reads and process file listed in the file abi_file via `-if`.
        # we must then create a temporary file containing only the name of the abi_file.
        with open('tempfile', 'w') as tempfile:
            tempfile.write(abi_file.name + "\n")

        # subprocess.call takes a list of argument as abi_file.
        # the following list describes the phred list of argument.
        phred = [
            "phred",
            "-st",
            "fasta",  # sequence type output (default = fasta)
            "-trim_alt",
            "\"\"",  # quality trim
            "-trim_cutoff",
            str(cutoff),  # error probability of trimming
            "-trim_fasta",  # trim sortie fasta.
            "-trim_phd",  # trim sortie phd
            "-s",  # write seq file, append ".seq" to the names of the abi_file files
            "-d",  # write a poly file
            "-p",  # write a phd file
            "-if",
            "tempfile"  # abi_file file
        ]
        phred_call = sub.call(phred)
        os.remove("tempfile")  # supprime le fichier temporaire
        return phred_call

    def run_muscle(phred_output, reference, clw=False):
        """Run muscle on the phred_output sequence, and align it to the reference sequence.
        :param phred_output: the fasta sequence to align.
        :param reference: the reference fasta sequence.

        """
        assert is_fasta(
            phred_output), "La séquence n'est pas un fichier fasta."
        assert is_fasta(
            reference.name), "La référence n'est pas un fichier fasta."

        muscle = [
            "muscle",
            "-quiet",  # non verbose
            "-profile",  # do not disrupt the profile alignment
            # "-clw",
            # "-objscore",
            # "ps",  # matrice de scoring
            # "-maxmb",
            # str(100),  # 100M as max memory
            "-in1",
            phred_output,
            "-in2",
            reference.name,  # profile is reference
            "-out",
            phred_output + ".aln"  # append .aln to phred_output name
        ]
        if clw:
            muscle.append("-clw")

        muscle_call = sub.call(muscle)  # call muscle list on input
        return muscle_call  # return 0 or 1 if muscle is successful.

    def reverse_complement(seq_in, seq_out):
        """Read seq_in and writes its reverse complement to seq_out.

        :param seq_in: sequence to reverse comp. str
        :param seq_out: sequence to write revcomp to. str
        :returns: None.
        :rtype: NoneType.

        """
        record = SeqIO.read(open(seq_in), "fasta")
        SeqIO.write(record.reverse_complement(), open(seq_out, 'w'), 'fasta')

    phred_code = run_phred(input, cutoff)

    phred_output = os.path.basename(input.name) + ".seq"
    if reverse:
        reverse_complement(phred_output, phred_output + ".rev")
        phred_output += ".rev"

    muscle_code = run_muscle(phred_output, ref, clustalw)

    if phred_code == 0 and muscle_code == 0:
        print "Phruscle ran fine."
    elif muscle_code != 0:
        print "Muscle failed."
    else:
        print "Phred failed."

##-----------------------------------------------------------------------------
## TABLE
##-----------------------------------------------------------------------------
# for line in reversed(open("filename").readlines()):
#     print line.rstrip()


@phruscle.command('table',
                  short_help="Make a table of SNP quality and polarity")
@click.option('-i', '--input', help="Input alignment in fasta format.")
@click.option(
    '-p',
    '--phd',
    help="Input sequence quality and position file, output by phred.")
@click.option('-o',
              '--output',
              type=click.File('wb'),
              default='-', # default is print to stdin
              help="Output file in csv format. Default is STDOUT.")
@click.option(
    '-r',
    '--reverse',
    is_flag=True,
    help=
    "Reverse the phd file. Useful when reference and sequence are not in the same direction."
)
def clean_output(input, phd, output, reverse=False):
    """This programme takes a fasta alignment between the experimental sequence and the
    reference alignment, find the quality of the base call in the phd file, and outputs it
    as csv.

    \b
    To read the consensus (cons) output:
    - `.` : the three bases are the same.
    - `x` : the sequenced base matches to the snp base.
    - `X` : the sequenced base matches the WT base.
    - `-` : the sequenced base is misaligned.
    - `N` : the base was not called.

    """

    def parse_muscle(align):
        """Cette fonction renvoit un dict comprenant 3 choses :
        1. la séquence alignée
        2. la séquence sauvage
        3. la séquence avec les SNP
        """
        assert is_fasta(align), "Le fichier n'est pas un fichier fasta"

        def read_seq(sequence, index):
            """quick wrapper around AlignIO.read()"""
            return AlignIO.read(sequence, "fasta")[index]

        return {
            'exp': str(read_seq(align, 0).seq),  # la séquence expérimentale
            'wt': str(read_seq(align, 1).seq),  # la séquence de référence
            'snp': str(read_seq(align, 2).seq)  # gène synthétique
        }

    def are_the_same(seq_list):
        """Détermine si les trois bases sont identiques. Renvoit `.` quand les trois bases sont
        identiques, `x` quand la base exp est la base `snp`, `X` quand la base exp est la base
        wt, et '-' quand la base exp ne correspond à aucune des possibilités

        """
        exp, snp, wt = seq_list

        if exp == '-':  # si la base a été trimmée ou non alignée
            return '-'
        elif exp == snp and snp == wt:  # si les trois bases sont identiques
            return '.'
        elif exp == snp and snp != wt:  # si la base correspond au SNP
            return 'x'
        elif exp != snp and exp == wt:  # si la base correspond au WT
            return 'X'
        else:
            return 'N'  # si c'est encore autre chose ?

    def index_seq(sequence):
        """Détermine la position dans la séquence expérimentale"""

        position = 0
        position_list = []
        for index, base in enumerate(sequence):
            if base != '-': position += 1
            position_list.append(str(position))

        return position_list

    def polarity_snp(parsed_aln):
        """Give back the polarity of the SNP. Expect an output of parse_muscle."""

        consensus = []
        for i, base in enumerate(parsed_aln['exp']):
            exp = parsed_aln['exp'][i]
            snp = parsed_aln['snp'][i]
            wt = parsed_aln['wt'][i]

            consensus += are_the_same([exp, snp, wt])

        return consensus

    def parse_phd(align, rev=False):
        """Return a pandas DataFrame by parsing a phred output.

        :param align: a phd output.

        """

        def get_phd_seq_only(phd_file, reverse=False):
            """Return string from BEGIN_DNA to END_DNA. If reverse is True, give the
            sequence in inverse order."""
            ## inspiré de
            ## http://stackoverflow.com/questions/7559397/python-read-file-from-and-to-specific-lines-of-textq,
            ## réponse de EOL
            block = ""
            found = False
            with open(phd_file, 'r') as in_data:
                if not reverse:
                    for line in in_data:
                        if found:
                            if line.strip() == "END_DNA": break
                            else: block += line
                        else:
                            if line.strip() == "BEGIN_DNA":
                                found = True
                                block = ""
                else:
                    # dans l'autre sens.
                    for line in reversed(in_data.readlines()):
                        if found:
                            if line.strip() == "BEGIN_DNA": break
                            else: block += line
                        else:
                            if line.strip() == "END_DNA":
                                found = True
                                block = ""
            return block

        # pd.DataFrame.
        return pd.read_table(
            io.StringIO(u"%s" % get_phd_seq_only(align,
                                                 reverse=rev)),
            sep=" ",
            names=['base', 'qual', 'phase'])  # 'phase' = spectrogramme pos

    parsed_align = parse_muscle(input)

    clean_data = pd.DataFrame({
        'seqp': index_seq(parsed_align['exp']),
        'seqb': list(parsed_align['exp']),
        'refp': index_seq(parsed_align['wt']),
        'refb': list(parsed_align['wt']),
        'snpb': list(parsed_align['snp']),
        'cons': polarity_snp(parsed_align),
        'name': input
    })

    ## use pandas concat to concatenate two datasets along the axis 1, equivalent to cbind in R.
    ## ignore_index indicate that the two dataframes are not combined with their index.
    with_phd = pd.concat(
        [
            clean_data[clean_data.cons != '-'].reset_index(drop=True),
            # ne garde que les positions qui existent dans le phd file
            parse_phd(phd,
                      rev=reverse)
            # parse the phred output. reverse it if necessary to align to the reference.
        ],
        axis=1,
        ignore_index=True)
    # change les noms de colonnes.
    with_phd.columns = ['cons', 'name', 'refb', 'refp', 'seqb', 'seqp', 'snpb',
                        'base', 'qual', 'phase']

    if output != '-':
        with_phd.to_csv(output, index=False)
    else:
        click.echo(with_phd, file=output)
#+END_SRC

Le script suivant est un script pour déployer =phruscle=.

#+BEGIN_SRC python :tangle setup.py
from setuptools import setup, find_packages

setup(name="phruscle",
      version="0.0.1",
      py_modules=["phruscle"],
      packages=find_packages('src'),
      package_dir={'': 'src'},
      install_requires=[
          'Click',
          'Biopython',
          'numpy',
          'pandas',
      ],
      entry_points='''
        [console_scripts]
        phruscle=phruscle:phruscle
    ''', )
#+END_SRC
Le script est là : [[./src/phruscle]].

Avec la commande suivante :
#+BEGIN_SRC sh
phruscle table -i pW85-1073.ab1 -o test.csv
#+END_SRC

Je produit une table csv, que j'analyse rapidement dans R.

#+BEGIN_SRC R :file tmp/test_qual.pdf :results output graphics
library(dplyr)
library(ggplot2)

setwd("./tmp")
test <- read.csv("test.csv") %>% tbl_df()

test %>%
  qplot(data= ., x = refp, y = qual, geom = c("point", "line"), color = qual)
#+END_SRC

#+RESULTS:
[[file:tmp/test_qual.pdf]]

À priori tout est bon. Le but est maintenant d'utiliser ce script sur un grand
nombre de séquence.

** phruscling et autres joyeusetés…

Le script phruscle est pour l'instant suffisamment fonctionnel pour qu'on puisse
l'utiliser sur l'ensemble des séquences ab1 dont on dispose. Il faut auparavant
recréer l'alignement entre la séquence sauvage et la séquence snp de WS et SW.

*** alignement WS et SW

J'utilise muscle pour faire l'alignement entre la séquence sauvage et les
séquences SW et WS.

#+BEGIN_SRC sh :tangle src/make_ref :shebang "#!/usr/bin/env bash"
muscle \
    -profile \
    -in1 raw/ref/strong-weak.fasta \
    -in2 raw/ref/reference1073bis-1392.fasta \
    -out raw/ref/aln-sw-ref.fst

muscle \
    -profile \
    -in1 raw/ref/weak-strong.fasta \
    -in2 raw/ref/reference1073bis-1392.fasta \
    -out raw/ref/aln-ws-ref.fst
#+END_SRC

*** run phruscle on it

#+BEGIN_SRC sh :results none :shebang "#!/usr/bin/env bash" :tangle src/phruscler
ROOT=`pwd`

mkdir data/ws/aln
mkdir data/sw/aln

cd data/ws/aln

for file in ../spectro/*.ab1
do
    phruscle basecall \
			       --input $file \
			       --ref $ROOT/raw/ref/aln-ws-ref.fst \
			       --reverse

	  phruscle table \
			       --input `basename $file`.seq.rev.aln \
			       --phd `basename $file`.phd.1 \
			       --output `basename $file`.csv \
			       --reverse
done

cd ../../sw/aln

for file in ../spectro/*.ab1
do
    phruscle basecall \
			       --input $file \
			       --ref $ROOT/raw/ref/aln-sw-ref.fst \
			       --reverse

	  phruscle table \
			       --input `basename $file`.seq.rev.aln \
			       --phd `basename $file`.phd.1 \
			       --output `basename $file`.csv \
			       --reverse
done
#+END_SRC


* Tests

La fonction /assert/ provient de là :
[[http://tldp.org/LDP/abs/html/debugging.html#ASSERT]]

Le script en question vient de là : https://github.com/lehmannro/assert.sh

#+BEGIN_SRC sh
wget https://raw.github.com/lehmannro/assert.sh/v1.1/assert.sh -O test/assert.sh
chmod +x test/assert.sh
#+END_SRC

Le script pour tester les résultats, via =make test=.

#+BEGIN_SRC sh :tangle test/test.sh
  #!/bin/bash

  # cette fonction renvoit le nombre de séquence dans un fichier fastq poolé.
  # elle divise le nombre de ligne par 4 pour connaître le nombre de séquence.
  check_fastq_length () {
      cat $1 | echo $((`wc -l` / 4))
  }

  set -e

  . ./test/assert.sh

  # vérifie qu'il y ait bien 95 séquence dans le fastq SW et 96 dans le fastq WS
  assert "echo `check_fastq_length data/sw/sw_untrimmed.fastq`" "95"
  assert "echo `check_fastq_length data/ws/ws_untrimmed.fastq`" "96"

  # vérifie qu'yl y ait bien 95 séquences dans le fastq SW trimmé et 96
  # dans le fastq WS trimmé
  assert "echo `check_fastq_length data/sw/sw_untrimmed.fastq.trim`" "90"
  assert "echo `check_fastq_length data/ws/ws_untrimmed.fastq.trim`" "90"
  assert "echo `wc -l data/snp_call/snp_calling.dat | awk '{print $1}'`" "1875"

  assert_end results
#+END_SRC

* Dépendances
** BBmap
Le site de téléchargement est là :
https://sourceforge.net/projects/bbmap

Pour installer bbduk :

#+BEGIN_SRC sh
  wget https://sourceforge.net/projects/bbmap/files/latest/download \
       -o bin/bbmap.tar.gz
  cd bin
  tar xzf bin/bbmap.tar.gz
#+END_SRC

** R markdown
Il faut une version récente du package =rmarkdown=.

#+begin_src R :tangle no
install.package('rmarkdown', type = "source")
#+end_src

* Config                                                           :noexport:
